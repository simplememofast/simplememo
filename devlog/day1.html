<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-EPZVZKCVQG"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-EPZVZKCVQG');
  </script>
  <title>【開発日誌 Day1】Captioが好きすぎて、もう一度"あの体験"を作りたくなった | Capito式シンプルメモ</title>
  <meta name="description" content="Captioの体験を分解し、UIKit・Outboxアーキテクチャ・Relay API・プライバシー設計まで、すべての技術判断を記録した開発日誌Day1。起動0.3秒、送信150ms、取りこぼしゼロを実現する設計。">
  <meta name="theme-color" content="#000000">
  <meta name="robots" content="index, follow">
  <meta name="author" content="Capito式シンプルメモ開発チーム">
  <meta name="keywords" content="Captio, 代替, alternative, シンプルメモ, Simple Memo, UIKit, SwiftUI, Outbox, Cloudflare Workers, プライバシー, iOS開発, 開発日誌">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;600;700&display=swap">

  <!-- Meta Templates for JS -->
  <div class="meta-templates" style="display:none;">
    <div class="meta-template" data-lang="ja">
      <span class="meta-title">【開発日誌 Day1】Captioが好きすぎて、もう一度"あの体験"を作りたくなった | Capito式シンプルメモ</span>
      <span class="meta-og-title">【開発日誌 Day1】Captioが好きすぎて、もう一度"あの体験"を作りたくなった</span>
      <span class="meta-description">Captioの体験を分解し、UIKit・Outboxアーキテクチャ・Relay API・プライバシー設計まで、すべての技術判断を記録した開発日誌Day1。起動0.3秒、送信150ms、取りこぼしゼロを実現する設計。</span>
    </div>
    <div class="meta-template" data-lang="en">
      <span class="meta-title">[Dev Log Day 1] Loved Captio So Much, I Had to Recreate That Experience | Simple Memo - Captio-style</span>
      <span class="meta-og-title">[Dev Log Day 1] Loved Captio So Much, I Had to Recreate That Experience</span>
      <span class="meta-description">Dissecting the Captio experience and documenting every technical decision: UIKit architecture, Outbox pattern, Relay API, and privacy-first design. Launch in 0.3s, send in 150ms, zero message loss.</span>
    </div>
  </div>

  <!-- OGP -->
  <meta property="og:title" content="【開発日誌 Day1】Captioが好きすぎて、もう一度&quot;あの体験&quot;を作りたくなった">
  <meta property="og:description" content="Captioの体験を分解し、UIKit・Outboxアーキテクチャ・Relay API・プライバシー設計まで、すべての技術判断を記録した開発日誌Day1。起動0.3秒、送信150ms、取りこぼしゼロを実現する設計。">
  <meta property="og:type" content="article">
  <meta property="og:url" content="https://simplememofast.com/devlog/day1.html">
  <meta property="og:image" content="/assets/img/ogp.png">
  <meta property="og:site_name" content="Capito式シンプルメモ">
  <meta property="og:locale" content="ja_JP">
  <meta property="og:locale:alternate" content="en_US">
  <meta property="article:published_time" content="2026-02-13T00:00:00+09:00">
  <meta property="article:author" content="Capito式シンプルメモ開発チーム">
  <meta property="article:section" content="Development">
  <meta property="article:tag" content="Captio">
  <meta property="article:tag" content="UIKit">
  <meta property="article:tag" content="Outbox Architecture">
  <meta property="article:tag" content="Privacy">
  <meta property="article:tag" content="Swift">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="【開発日誌 Day1】Captioが好きすぎて、もう一度&quot;あの体験&quot;を作りたくなった">
  <meta name="twitter:description" content="Captioの体験を分解し、UIKit・Outboxアーキテクチャ・Relay API・プライバシー設計まで、すべての技術判断を記録した開発日誌Day1。">
  <meta name="twitter:image" content="/assets/img/ogp.png">

  <link rel="canonical" href="https://simplememofast.com/devlog/day1.html">

  <!-- Favicon -->
  <link rel="icon" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon/apple-touch-icon.png">
  <link rel="manifest" href="/assets/favicon/site.webmanifest">

  <link rel="stylesheet" href="/assets/css/style.css">
  <style>
    .lang-switcher-container { display: flex; justify-content: flex-end; padding: 1.25rem 0; }
    .lang-switcher { display: inline-flex; background: rgba(15, 20, 30, 0.6); backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px); border: 1px solid rgba(100, 160, 220, 0.12); border-radius: 22px; padding: 3px; overflow: hidden; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2); }
    .lang-switcher__btn { background: transparent; border: none; color: rgba(255, 255, 255, 0.5); padding: 0.5rem 1.1rem; border-radius: 19px; cursor: pointer; font-size: 0.8rem; font-weight: 500; transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1); letter-spacing: 0.02em; }
    .lang-switcher__btn:hover { color: rgba(255, 255, 255, 0.85); }
    .lang-switcher__btn:focus-visible { outline: 2px solid #6ab4ff; outline-offset: 2px; }
    .lang-switcher__btn.active { background: rgba(100, 180, 255, 0.12); border: 1px solid rgba(100, 180, 255, 0.2); color: #fff; box-shadow: 0 0 12px rgba(100, 180, 255, 0.1); }
    [data-lang] { display: none; }
    [data-lang].active { display: block; }
    span[data-lang].active { display: inline; }
    @media (prefers-reduced-motion: reduce) { .lang-switcher__btn { transition: none; } }

    pre { background: rgba(0,0,0,0.4); border: 1px solid var(--border); border-radius: 8px; padding: 16px; overflow-x: auto; margin: 16px 0; }
    code { font-family: 'SF Mono', Monaco, monospace; font-size: 0.85rem; color: #e0e0e0; }
    .article-meta { text-align: center; margin-bottom: 30px; color: var(--text-muted); font-size: 0.85rem; }
    .article-toc { background: rgba(15,20,30,0.5); border: 1px solid var(--border); border-radius: var(--radius-lg); padding: 20px 24px; margin-bottom: 30px; }
    .article-toc h2 { font-size: 0.95rem; margin-bottom: 12px; }
    .article-toc ol { padding-left: 20px; }
    .article-toc li { margin-bottom: 6px; }
    .article-toc a { color: var(--accent); text-decoration: none; font-size: 0.88rem; }
    .article-toc a:hover { text-decoration: underline; }
    .related-topics { margin-top: 50px; }
    .related-topics h2 { font-size: 1.1rem; margin-bottom: 16px; }
    .related-grid { display: grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 600px) { .related-grid { grid-template-columns: 1fr 1fr; } }
    .related-card { background: rgba(15,20,30,0.4); border: 1px solid var(--border); border-radius: var(--radius-md); padding: 16px; text-decoration: none; color: inherit; display: block; transition: border-color 0.25s; }
    .related-card:hover { border-color: rgba(100,180,255,0.3); }
    .related-card__title { font-size: 0.9rem; font-weight: 600; color: var(--text-primary, #fff); margin-bottom: 4px; }
    .related-card__desc { font-size: 0.8rem; color: var(--text-secondary); }
  </style>

  <!-- JSON-LD: Article -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "【開発日誌 Day1】Captioが好きすぎて、もう一度\"あの体験\"を作りたくなった",
    "description": "Captioの体験を分解し、UIKit・Outboxアーキテクチャ・Relay API・プライバシー設計まで、すべての技術判断を記録した開発日誌Day1。",
    "datePublished": "2026-02-13T00:00:00+09:00",
    "dateModified": "2026-02-13T00:00:00+09:00",
    "author": {
      "@type": "Organization",
      "name": "Capito式シンプルメモ開発チーム",
      "url": "https://simplememofast.com"
    },
    "publisher": {
      "@type": "Organization",
      "name": "Capito式シンプルメモ",
      "url": "https://simplememofast.com",
      "logo": {
        "@type": "ImageObject",
        "url": "https://simplememofast.com/assets/img/ogp.png"
      }
    },
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https://simplememofast.com/devlog/day1.html"
    },
    "image": "https://simplememofast.com/assets/img/ogp.png",
    "articleSection": "Development",
    "keywords": ["Captio", "UIKit", "SwiftUI", "Outbox", "Cloudflare Workers", "Privacy", "iOS", "Swift"],
    "inLanguage": ["ja", "en"],
    "isPartOf": {
      "@type": "WebSite",
      "name": "Capito式シンプルメモ",
      "url": "https://simplememofast.com"
    }
  }
  </script>

  <!-- JSON-LD: BreadcrumbList -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": [
      { "@type": "ListItem", "position": 1, "name": "ホーム", "item": "https://simplememofast.com/" },
      { "@type": "ListItem", "position": 2, "name": "開発日誌", "item": "https://simplememofast.com/devlog/" },
      { "@type": "ListItem", "position": 3, "name": "Day1: Captioが好きすぎて、もう一度\"あの体験\"を作りたくなった", "item": "https://simplememofast.com/devlog/day1.html" }
    ]
  }
  </script>

  <!-- JSON-LD: FAQPage -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "FAQPage",
    "mainEntity": [
      {
        "@type": "Question",
        "name": "Captioとは何ですか？ / What is Captio?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "Captioは、メモを書いてワンタップで自分のメールに送信できるiOSアプリでした。極限までシンプルなUIで、起動した瞬間にテキスト入力が可能で、送信後は即座に画面がクリアされるという体験が特徴でした。残念ながらサービスは終了しましたが、Capito式シンプルメモはその体験を再現するために開発されました。 / Captio was an iOS app that let you write a memo and send it to your email with a single tap. It featured an extremely simple UI where text input was ready the moment you launched the app, and the screen cleared instantly after sending. Unfortunately, the service was discontinued, but Simple Memo (Captio-style) was developed to recreate that experience."
        }
      },
      {
        "@type": "Question",
        "name": "なぜSwiftUIではなくUIKitを使ったのですか？ / Why UIKit instead of SwiftUI?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "Time-to-Text（起動からテキスト入力可能になるまでの時間）を500ms以下にするという目標のためです。SwiftUIのbody再評価やStateObject初期化のオーバーヘッドを避け、SceneDelegateから直接ViewControllerを生成し、viewDidAppearでbecomeFirstResponderを呼ぶことで、実機計測200〜300msを達成しました。 / To achieve our goal of Time-to-Text (time from launch to text input ready) under 500ms. By avoiding SwiftUI's body re-evaluation and StateObject initialization overhead, directly creating ViewControllers from SceneDelegate, and calling becomeFirstResponder in viewDidAppear, we achieved 200-300ms on real devices."
        }
      },
      {
        "@type": "Question",
        "name": "オフラインでもメモは失われませんか？ / Are memos lost when offline?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "いいえ、メモは失われません。Outboxアーキテクチャにより、送信ボタンを押した瞬間にAES-GCM暗号化されたメモがローカルのOutboxに保存されます。ネットワーク送信はバックグラウンドで行われ、失敗時はExponential Backoffで再試行します。オフライン時はNWPathMonitorで接続を監視し、復帰時に自動再送します。 / No, memos are never lost. With the Outbox architecture, the moment you tap send, the memo is saved to a local Outbox with AES-GCM encryption. Network transmission happens in the background, with exponential backoff retry on failure. When offline, NWPathMonitor watches for connectivity and auto-resends when connection is restored."
        }
      },
      {
        "@type": "Question",
        "name": "メモの内容はサーバーに保存されますか？ / Is memo content stored on the server?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "いいえ、サーバーにメモ内容は保存されません。Relay APIはCloudflare Workers上で動作し、メモ内容はメール送信のためにのみ一時的に処理され、永続的に保存されることはありません。さらに、ephemeral URLSession（キャッシュなし・クッキーなし）を使用し、ログにもメモ内容は一切記録されません。DEBUGビルドでも同様です。 / No, memo content is never stored on the server. The Relay API runs on Cloudflare Workers and only temporarily processes memo content for email delivery without persistent storage. Additionally, ephemeral URLSession (no cache, no cookies) is used, and memo content is never recorded in logs, even in DEBUG builds."
        }
      },
      {
        "@type": "Question",
        "name": "Captio式シンプルメモは無料ですか？ / Is Simple Memo free?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "7日間の無料トライアル（送信無制限）があります。トライアル終了後、Freeプランでは1日3通まで送信可能です。Premiumプラン（月額¥500 / $2.99、年額¥5,000 / $29.99）では送信無制限でご利用いただけます。 / There is a 7-day free trial with unlimited sends. After the trial, the Free plan allows up to 3 sends per day. The Premium plan (monthly ¥500 / $2.99, yearly ¥5,000 / $29.99) offers unlimited sends."
        }
      }
    ]
  }
  </script>
</head>
<body>
  <header class="page-header">
    <div class="container">
      <div class="lang-switcher-container">
        <div class="lang-switcher">
          <button class="lang-switcher__btn" data-lang-btn="ja">日本語</button>
          <button class="lang-switcher__btn" data-lang-btn="en">English</button>
        </div>
      </div>
      <div class="page-header__inner">
        <a href="/" class="page-header__logo">
          <span data-lang="ja">Capito式シンプルメモ</span>
          <span data-lang="en">Simple Memo - Captio-style</span>
        </a>
        <a href="/devlog/" class="page-header__back">
          <span data-lang="ja">開発日誌一覧へ</span>
          <span data-lang="en">Back to Dev Log</span>
        </a>
      </div>
    </div>
  </header>

  <main class="page-content">
    <div class="container">

      <!-- ======================== -->
      <!-- JAPANESE VERSION         -->
      <!-- ======================== -->
      <div data-lang="ja">
        <h1 class="page-content__title">【開発日誌 Day1】Captioが好きすぎて、もう一度"あの体験"を作りたくなった</h1>
        <div class="article-meta">2026年2月13日</div>

        <!-- Table of Contents -->
        <nav class="article-toc">
          <h2>目次</h2>
          <ol>
            <li><a href="#ja-intro">はじめに：Captioという存在</a></li>
            <li><a href="#ja-section1">Captioの「何」が良かったのか——体験を分解してみた</a></li>
            <li><a href="#ja-section2">アーキテクチャ：なぜSwiftUI「ではなく」UIKitなのか</a></li>
            <li><a href="#ja-section3">「送ったら消える」を150ミリ秒で実現する設計</a></li>
            <li><a href="#ja-section4">「取りこぼしゼロ」を実現するOutboxアーキテクチャ</a></li>
            <li><a href="#ja-section5">Relay API：Gmail依存からの脱却</a></li>
            <li><a href="#ja-section6">今日やったこと：小さな違和感を、ひとつずつ消す</a></li>
            <li><a href="#ja-section7">Historyの表示ステータス不整合を解消した</a></li>
            <li><a href="#ja-section8">プライバシーへの偏執的なこだわり</a></li>
            <li><a href="#ja-section9">10言語対応：世界中のCaptioユーザーに届けたい</a></li>
            <li><a href="#ja-section10">今日の学び：プロダクトは「安心感」の設計</a></li>
            <li><a href="#ja-section11">次回（Day2）予告</a></li>
          </ol>
        </nav>

        <div class="page-content__body">

          <!-- Introduction -->
          <section id="ja-intro">
            <p>Captioというアプリを知っているだろうか。</p>
            <p>メモを書いて、送信ボタンを押す。それだけで、自分のメールアドレスにメモが届く。起動した瞬間にキーボードが表示され、書いたら送る、送ったら消える。余計な機能は一切ない。ただそれだけのアプリだった。</p>
            <p>でも「ただそれだけ」が、とてつもなく心地よかった。</p>
            <p>通勤電車の中で思いついたアイデア、会議中にふと浮かんだタスク、寝る前に頭をよぎった一言——Captioはそのすべてを、1秒以内にメールボックスに届けてくれた。メモアプリを開いて、フォルダを選んで、タイトルを付けて……という煩わしさが一切ない。その「摩擦ゼロ」の体験は、一度知ったら手放せなくなるものだった。</p>
            <p>そのCaptioが、サービスを終了した。</p>
            <p>代替アプリをいくつか試したが、どれもあの体験には程遠かった。起動が遅い、UIに余計な要素がある、送信後にメモが残る——些細な違いに見えるかもしれないが、Captioが作り上げた体験の本質は、まさにそういった「些細なこと」の積み重ねだった。</p>
            <p>だから、自分で作ることにした。Captioの体験を、もう一度。</p>
            <p>これは「Capito式シンプルメモ」の開発日誌Day1。この記事では、Captioの体験を分解し、それを現代の技術スタックでどう再現するか、すべての技術的判断を記録する。</p>
          </section>

          <!-- Section 1 -->
          <section id="ja-section1">
            <h2>1. Captioの「何」が良かったのか——体験を分解してみた</h2>
            <p>Captioの体験を言語化するために、3つの要素に分解してみた。</p>

            <h3>要素1：起動即入力（Instant Launch-to-Input）</h3>
            <p>Captioを起動すると、即座にキーボードが表示され、テキスト入力が可能になる。スプラッシュスクリーンの後にホーム画面が表示されて、そこからメモ作成ボタンを押して……という手順がない。起動＝入力。この「起動からテキスト入力可能になるまでの時間」を、私たちは<strong>Time-to-Text</strong>と呼んでいる。Captioのそれは、体感で0.5秒以下だった。</p>

            <h3>要素2：送ったらすぐ消える（Instant Clear After Send）</h3>
            <p>送信ボタンを押すと、画面は即座にクリアされる。「送信中…」のプログレスバーを見つめて待つ時間がない。書いたメモが消えた瞬間、「ああ、送れたな」という安心感とともに次の行動に移れる。この「送信ボタンを押してからUIがクリアされるまでの時間」を、私たちは<strong>Send-to-Reset</strong>と呼んでいる。目標は150ms以下だ。</p>

            <h3>要素3：余計なものが一切ない（Nothing Unnecessary）</h3>
            <p>フォルダ機能、タグ機能、リッチテキスト、マークダウン対応——Captioにはそのどれもなかった。あるのはテキスト入力欄と送信ボタンだけ。この潔さが、認知負荷をゼロに近づけていた。「何をすべきか」を考える必要がないアプリ。それがCaptioだった。</p>

            <p>この3つの要素を、現代のiOS開発で再現する。それが「Capito式シンプルメモ」のミッションだ。</p>
          </section>

          <!-- Section 2 -->
          <section id="ja-section2">
            <h2>2. アーキテクチャ：なぜSwiftUI「ではなく」UIKitなのか</h2>
            <p>2026年のiOS開発で、SwiftUIではなくUIKitを選ぶのは異端に見えるかもしれない。しかし、私たちの最優先目標は明確だった——<strong>Time-to-Text 500ms以下</strong>。</p>

            <p>SwiftUIの`body`再評価、`StateObject`の初期化、`@Environment`の解決——これらのオーバーヘッドは通常のアプリ開発では無視できる範囲だが、「起動即入力」を実現するには無視できない。1msでも速く、テキストフィールドにフォーカスを当てたい。</p>

            <p>そこで採用したのが、<strong>Storyboardを使わないUIKit直接構築</strong>だ。</p>

            <p>SceneDelegateでwindowを生成し、rootViewControllerに直接ComposeViewControllerを設定する。Storyboardのパース処理すらスキップする。</p>

<pre><code>// SceneDelegate.swift
func scene(_ scene: UIScene,
           willConnectTo session: UISceneSession,
           options connectionOptions: UIScene.ConnectionOptions) {
    guard let windowScene = (scene as? UIWindowScene) else { return }
    let window = UIWindow(windowScene: windowScene)
    window.rootViewController = ComposeViewController()
    window.makeKeyAndVisible()
    self.window = window
}</code></pre>

            <p>そしてComposeViewControllerの`viewDidAppear`で、即座にテキストビューにフォーカスを当てる。</p>

<pre><code>// ComposeViewController.swift
override func viewDidAppear(_ animated: Bool) {
    super.viewDidAppear(animated)
    textView.becomeFirstResponder()
}</code></pre>

            <p>この2つのコードだけで、起動からキーボード表示までのパスが最短になる。</p>

            <p>実機計測の結果は<strong>200〜300ms</strong>。目標の500msを大幅に下回った。SwiftUIで同等のことを実現しようとすると、`@FocusState`の遅延やbody再評価のタイミングの問題で、安定して500ms以下を達成するのは困難だった。</p>

            <p>UIKitは「古い」かもしれない。しかし「速い」。この1点において、UIKitは今でも最良の選択肢だ。</p>
          </section>

          <!-- Section 3 -->
          <section id="ja-section3">
            <h2>3. 「送ったら消える」を150ミリ秒で実現する設計</h2>
            <p>Captioの「送ったら消える」体験を再現するために、最も重要な設計判断がある。それは、<strong>送信アニメーションとUIクリアを、ネットワークレスポンスから完全に分離する</strong>ことだ。</p>

            <p>一般的なアプリの送信フローはこうだ：</p>
            <ol>
              <li>送信ボタンを押す</li>
              <li>ローディングインジケーターを表示</li>
              <li>サーバーからのレスポンスを待つ</li>
              <li>成功ならUIをクリア、失敗ならエラーを表示</li>
            </ol>

            <p>このフローでは、ネットワークの遅延がそのままUIの遅延になる。私たちのフローはこうだ：</p>
            <ol>
              <li>送信ボタンを押す</li>
              <li><strong>即座に</strong>UIをクリア（アニメーション: 0.25秒）</li>
              <li>バックグラウンドでネットワーク送信</li>
              <li>成功→静かにOutboxから削除 / 失敗→バックグラウンドでリトライ</li>
            </ol>

<pre><code>// ComposeViewController.swift
private func performSendAnimation() {
    UIView.animate(withDuration: 0.25,
                   delay: 0,
                   options: .curveEaseOut) {
        self.textView.alpha = 0
        self.subjectField.alpha = 0
    } completion: { _ in
        self.textView.text = ""
        self.subjectField.text = ""
        self.textView.alpha = 1
        self.subjectField.alpha = 1
        self.textView.becomeFirstResponder()
    }
}</code></pre>

            <p>ユーザーにとっては、送信ボタンを押した瞬間にメモが「消えて」、次のメモを書ける状態になる。ネットワークの成功・失敗は、ユーザーの目に見えないところで処理される。</p>

            <p>「でも、送信に失敗したらどうするの？」——その疑問に答えるのが、次のセクションのOutboxアーキテクチャだ。</p>
          </section>

          <!-- Section 4 -->
          <section id="ja-section4">
            <h2>4. 「取りこぼしゼロ」を実現するOutboxアーキテクチャ</h2>
            <p>送信UIをネットワークレスポンスから分離するということは、「UIはクリアされたけど、実はメール送信に失敗していた」という状況が起こり得るということだ。これは絶対に許容できない。ユーザーが「送った」と思ったメモが、実は送られていなかった——これはメモアプリにとって致命的な信頼の喪失だ。</p>

            <p>そこで採用したのが<strong>Outboxパターン</strong>だ。</p>

            <p>メッセージの送信フローは以下の通り：</p>
            <ol>
              <li><strong>送信ボタンタップ</strong>：メッセージをAES-GCM暗号化してOutbox（ローカルストレージ）に保存</li>
              <li><strong>UIクリア</strong>：performSendAnimationで即座に画面をクリア</li>
              <li><strong>バックグラウンド送信</strong>：Outboxからメッセージを取り出してRelay APIに送信</li>
              <li><strong>成功</strong>：Outboxからメッセージを削除</li>
              <li><strong>失敗</strong>：Exponential Backoffでリトライ（1秒→2秒→4秒→8秒…）</li>
              <li><strong>オフライン</strong>：NWPathMonitorで接続を監視し、復帰時に自動再送</li>
            </ol>

            <p>重要なのは、<strong>ネットワーク送信の前にOutboxに保存する</strong>という順序だ。これにより、アプリが突然クラッシュしても、端末の電源が落ちても、メッセージは失われない。</p>

            <p>Outboxに保存されるメッセージは、CryptoKitを使ったAES-GCM暗号化で保護される。暗号化キーはKeychainに保存され、アプリのサンドボックス外からはアクセスできない。</p>

<pre><code>// OutboxManager.swift
func enqueue(message: OutboxMessage) throws {
    let key = try KeychainHelper.getOrCreateSymmetricKey()
    let sealedBox = try AES.GCM.seal(
        message.plainData,
        using: key
    )
    let encrypted = EncryptedOutboxEntry(
        id: message.id,
        sealedData: sealedBox.combined!,
        createdAt: Date(),
        retryCount: 0
    )
    try persistenceStore.save(encrypted)
}</code></pre>

            <p>また、すべてを自前で実装しているため、<strong>外部ライブラリへの依存はゼロ</strong>だ。CryptoKit、NWPathMonitor、URLSession——すべてApple純正のフレームワークで完結する。サードパーティライブラリのバージョン管理やセキュリティ監査から解放されるのは、小規模チームにとって大きなメリットだ。</p>
          </section>

          <!-- Section 5 -->
          <section id="ja-section5">
            <h2>5. Relay API：Gmail依存からの脱却</h2>
            <p>Captioは当初、ユーザーのGmailアカウントを通じてメールを送信していた。しかし、GoogleのOAuth要件の変更やAPI制限により、この方式は持続可能ではない。</p>

            <p>私たちは<strong>Cloudflare Workers + Resend API</strong>という構成を選んだ。</p>

            <p>Cloudflare Workersはエッジコンピューティング基盤で、世界中のユーザーに最も近いデータセンターでコードが実行される。日本からのリクエストは日本のエッジで処理され、アメリカからのリクエストはアメリカのエッジで処理される。これにより、従来のサーバーレス（AWS Lambda等）と比べて、コールドスタートの問題がほぼ解消される。</p>

            <p>メール送信にはResend APIを使用する。Resendはデベロッパーフレンドリーなメール送信APIで、高い到達率と安定性を提供する。</p>

            <h3>メール認証フロー</h3>
            <p>ユーザーが宛先メールアドレスを設定する際、6桁の認証コードによるメール認証を行う。これにより、第三者のメールアドレスへの不正送信を防ぐ。</p>

            <h3>多層レート制限</h3>
            <p>不正利用を防ぐために、多層のレート制限を実装している。</p>

<pre><code>// Cloudflare Worker - Rate Limit Configuration
const RATE_LIMITS = {
  devicePerMinute: 30,    // 1デバイスあたり1分30回
  devicePerDay: 200,      // 1デバイスあたり1日200回
  ipPerHour: 120,         // 1IPあたり1時間120回
  globalPerDay: 300       // サービス全体で1日300回（調整可能）
};</code></pre>

            <p>デバイス単位、IP単位、グローバル単位の3層でレート制限をかけることで、単一デバイスの暴走もボットネット攻撃もブロックできる。</p>

            <h3>冪等性の保証</h3>
            <p>ネットワークの不安定さによる重複送信を防ぐため、各メッセージにUUIDを割り当て、Relay API側で重複チェックを行う。同じUUIDのメッセージが再送された場合、2回目以降はメール送信を行わずに成功レスポンスを返す。これにより、Outboxパターンのリトライ機構と組み合わせても、ユーザーが同じメモを二重に受信することはない。</p>
          </section>

          <!-- Section 6 -->
          <section id="ja-section6">
            <h2>6. 今日やったこと：小さな違和感を、ひとつずつ消す</h2>
            <p>Day1の実装作業の多くは、星評価ダイアログの見直しに費やした。App Storeの評価はアプリの生命線だが、ユーザー体験を損なう形で評価を求めてはいけない。</p>

            <h3>表示条件の再設計</h3>
            <p>星評価ダイアログの表示条件を以下のように設定した：</p>
            <ul>
              <li><strong>100通ごとに表示</strong>：十分にアプリを使い込んだユーザーにのみ表示</li>
              <li><strong>最低14日間の間隔</strong>：前回表示してから14日以上経過していること</li>
              <li><strong>閉じた後は30日間表示しない</strong>：ユーザーが閉じた場合、30日間は再表示しない</li>
            </ul>

            <h3>星アイコンのタップ領域修正</h3>
            <p>Apple Human Interface Guidelinesでは、タッチターゲットのサイズは最低44x44ptが推奨されている。星アイコンのタップ領域がこの基準を満たしていなかったため修正した。</p>

<pre><code>// StarRatingView.swift
private func createStarButton() -> UIButton {
    let button = UIButton(type: .custom)
    button.translatesAutoresizingMaskIntoConstraints = false
    NSLayoutConstraint.activate([
        button.widthAnchor.constraint(greaterThanOrEqualToConstant: 44),
        button.heightAnchor.constraint(greaterThanOrEqualToConstant: 44)
    ])
    return button
}</code></pre>

            <h3>星アイコンの歪み修正</h3>
            <p>UIStackViewの`.fillEqually` distributionが原因で星アイコンが歪んでいた問題を修正。`contentMode`を`.scaleAspectFit`に設定し、StackViewのdistributionを`.equalSpacing`に変更した。</p>

            <h3>評価後のフロー</h3>
            <ul>
              <li><strong>5つ星</strong>：App Storeのレビュー画面に遷移（`SKStoreReviewController`）</li>
              <li><strong>4つ星以下</strong>：「ありがとうございます」のトーストを静かに表示して終了。ネガティブなレビューをApp Storeに誘導しない。</li>
            </ul>
          </section>

          <!-- Section 7 -->
          <section id="ja-section7">
            <h2>7. Historyの表示ステータス不整合を解消した</h2>
            <p>送信履歴画面（History）で、あるバグに気づいた。送信が完了しているにも関わらず、ステータスが「送信中」のまま変わらないメッセージがあった。</p>

            <p>原因を調査した結果、ステータス更新のロジックに問題があることが判明した。従来の実装では、メッセージのテキスト内容をキーにしてステータスを更新していた。しかし、同じ内容のメモを複数回送信した場合、テキストベースの検索では正しいメッセージを特定できない。</p>

            <p>修正は単純明快だった。テキストベースの検索を<strong>IDベースのステータス更新</strong>に変更した。各メッセージにはOutbox保存時にUUIDが割り当てられているため、このIDを使ってHistoryのステータスを更新する。</p>

<pre><code>// HistoryManager.swift
// Before: テキストベースの検索（バグの原因）
// func updateStatus(forText text: String, status: SendStatus)

// After: IDベースのステータス更新
func updateStatus(forMessageId id: UUID, status: SendStatus) {
    guard let index = entries.firstIndex(where: { $0.messageId == id }) else {
        return
    }
    entries[index].status = status
    persistEntries()
}</code></pre>

            <p>この修正により、同じ内容のメモを何度送っても、それぞれのステータスが正しく表示されるようになった。</p>
          </section>

          <!-- Section 8 -->
          <section id="ja-section8">
            <h2>8. プライバシーへの偏執的なこだわり</h2>
            <p>メモアプリにはプライベートな情報が書き込まれる。パスワード、個人的な悩み、ビジネスアイデア——ユーザーが何を書くかは予測できない。だからこそ、プライバシー保護は「十分」ではなく「過剰」なくらいがちょうどいい。</p>

            <h3>アプリスイッチャーでのプライバシーオーバーレイ</h3>
            <p>iOSのアプリスイッチャーでは、アプリの画面がサムネイルとして表示される。メモの内容が第三者に見られるリスクを排除するため、アプリがバックグラウンドに移行する際にプライバシーオーバーレイを表示する。</p>

            <h3>Ephemeral URLSession</h3>
            <p>通常のURLSessionは、キャッシュ、クッキー、認証情報をディスクに保存する。私たちは`URLSessionConfiguration.ephemeral`を使用することで、これらの情報がディスクに一切残らないようにしている。メモの内容がキャッシュとしてストレージに残るリスクをゼロにする。</p>

            <h3>ログの無害化</h3>
            <p>開発中のデバッグログには注意が必要だ。「送信したメモの内容をログに出力する」という一見無害な処理が、セキュリティホールになり得る。私たちのポリシーは明確だ：</p>
            <ul>
              <li>メモの内容は、DEBUGビルドであっても<strong>一切ログに記録しない</strong></li>
              <li>エラーログでは`localizedDescription`を使わず、<strong>`type(of: error)`のみ</strong>を記録</li>
              <li>理由：`localizedDescription`にはユーザー入力が含まれる可能性があるため</li>
            </ul>

<pre><code>// NetworkManager.swift
// BAD: エラーの詳細をログに出力
// Logger.error("Send failed: \(error.localizedDescription)")

// GOOD: エラーの型のみをログに出力
Logger.error("Send failed: \(type(of: error))")</code></pre>

            <p>偏執的に見えるかもしれない。しかし、メモアプリを信頼して使ってもらうためには、この程度の偏執さが必要だと考えている。</p>
          </section>

          <!-- Section 9 -->
          <section id="ja-section9">
            <h2>9. 10言語対応：世界中のCaptioユーザーに届けたい</h2>
            <p>Captioは英語圏を中心に世界中にユーザーがいた。その元ユーザーたちに「Capito式シンプルメモ」を届けるために、初回リリースから10言語に対応した。</p>

            <p>対応言語：日本語、英語、スペイン語、フランス語、ドイツ語、イタリア語、ポルトガル語、韓国語、中国語（簡体字）、アラビア語。</p>

            <p>特に<strong>アラビア語のRTL（Right-to-Left）対応</strong>は技術的な挑戦だった。テキストの方向だけでなく、UIレイアウト全体をミラーリングする必要がある。Auto Layoutの`leading`/`trailing`制約を一貫して使うことで、RTL環境でも自然なレイアウトを実現している。</p>

            <h3>アプリ内言語切り替え</h3>
            <p>iOS 16以降のアプリ内言語切り替えに加え、独自の言語切り替えメカニズムも実装している。言語が切り替わった際は、ViewControllerを`cross-dissolve`トランジションで差し替えることで、スムーズな切り替え体験を提供する。</p>

<pre><code>// LanguageManager.swift
func applyLanguageChange() {
    guard let window = UIApplication.shared.connectedScenes
        .compactMap({ $0 as? UIWindowScene })
        .first?.windows.first else { return }

    let newVC = ComposeViewController()
    newVC.view.frame = window.bounds
    UIView.transition(with: window,
                      duration: 0.3,
                      options: .transitionCrossDissolve,
                      animations: {
        window.rootViewController = newVC
    })
}</code></pre>
          </section>

          <!-- Section 10 -->
          <section id="ja-section10">
            <h2>10. 今日の学び：プロダクトは「安心感」の設計</h2>
            <p>Day1を終えて思うのは、このプロダクトの本質は「安心感」の設計だということだ。</p>

            <p>技術的な数値をまとめてみる：</p>
            <ul>
              <li><strong>Time-to-Text</strong>：500ms以下（実測200〜300ms）</li>
              <li><strong>Send-to-Reset</strong>：150ms以下</li>
              <li><strong>メッセージの取りこぼし</strong>：ゼロ（Outboxパターン）</li>
              <li><strong>暗号化</strong>：AES-GCM（CryptoKit）</li>
              <li><strong>外部ライブラリ依存</strong>：ゼロ</li>
            </ul>

            <p>しかし、これらの数値はすべて「安心感」という一つの目標に集約される。</p>

            <p>起動が速い→「いつでもすぐ書ける」安心感。<br>
            送ったら消える→「処理された」安心感。<br>
            取りこぼしゼロ→「絶対に届く」安心感。<br>
            暗号化→「誰にも見られない」安心感。</p>

            <p>Captioが愛されたのは、機能が優れていたからではない。「安心して使える」体験を、徹底的に磨き上げていたからだ。それを引き継ぎたい。</p>
          </section>

          <!-- Section 11 -->
          <section id="ja-section11">
            <h2>11. 次回（Day2）予告</h2>
            <p>Day2では、以下のテーマに取り組む予定だ：</p>
            <ul>
              <li><strong>送信アニメーションの洗練</strong>：現在の0.25秒フェードアウトから、より心地よいアニメーションへ</li>
              <li><strong>Historyステータス更新のタイミング最適化</strong>：リアルタイム更新 vs バッチ更新の比較検討</li>
              <li><strong>成功トーストは本当に必要か？</strong>：送信成功のフィードバックについて、「表示しない」という選択肢の検討</li>
            </ul>
            <p>Captioの「何もない」潔さを目指して、Day2へ続く。</p>
          </section>

        </div>
      </div>

      <!-- ======================== -->
      <!-- ENGLISH VERSION          -->
      <!-- ======================== -->
      <div data-lang="en">
        <h1 class="page-content__title">[Dev Log Day 1] Loved Captio So Much, I Had to Recreate That Experience</h1>
        <div class="article-meta">February 13, 2026</div>

        <!-- Table of Contents -->
        <nav class="article-toc">
          <h2>Table of Contents</h2>
          <ol>
            <li><a href="#en-intro">Introduction: The App Called Captio</a></li>
            <li><a href="#en-section1">What Made Captio So Good -- Deconstructing the Experience</a></li>
            <li><a href="#en-section2">Architecture: Why UIKit Instead of SwiftUI</a></li>
            <li><a href="#en-section3">Achieving "Send and Clear" in 150 Milliseconds</a></li>
            <li><a href="#en-section4">Zero Message Loss: The Outbox Architecture</a></li>
            <li><a href="#en-section5">Relay API: Breaking Free from Gmail Dependency</a></li>
            <li><a href="#en-section6">Today's Work: Eliminating Small Annoyances One by One</a></li>
            <li><a href="#en-section7">Fixing History Status Display Inconsistencies</a></li>
            <li><a href="#en-section8">An Obsessive Commitment to Privacy</a></li>
            <li><a href="#en-section9">10 Languages: Reaching Captio Users Worldwide</a></li>
            <li><a href="#en-section10">Today's Lesson: Product Design Is About Trust</a></li>
            <li><a href="#en-section11">Day 2 Preview</a></li>
          </ol>
        </nav>

        <div class="page-content__body">

          <!-- Introduction -->
          <section id="en-intro">
            <p>Have you ever heard of an app called Captio?</p>
            <p>You write a memo, tap the send button. That's it -- your memo arrives in your email inbox. The keyboard appeared the instant you launched it. You wrote, you sent, it cleared. No extra features whatsoever. That was all the app did.</p>
            <p>But that "all it did" was extraordinarily comfortable.</p>
            <p>An idea on the commuter train, a task that popped into your head during a meeting, a thought before falling asleep -- Captio delivered all of them to your inbox within a second. No opening a notes app, choosing a folder, typing a title... none of that friction. Once you experienced that "zero friction" workflow, you couldn't let it go.</p>
            <p>Then Captio shut down.</p>
            <p>I tried several alternatives, but none came close to that experience. Slow launch times, unnecessary UI elements, memos lingering after send -- these might seem like minor differences, but the essence of what Captio had built was precisely the accumulation of these "minor things."</p>
            <p>So I decided to build it myself. The Captio experience, once more.</p>
            <p>This is Day 1 of the "Simple Memo (Captio-style)" development diary. In this article, I'll deconstruct the Captio experience and document every technical decision made to recreate it with a modern tech stack.</p>
          </section>

          <!-- Section 1 -->
          <section id="en-section1">
            <h2>1. What Made Captio So Good -- Deconstructing the Experience</h2>
            <p>To articulate the Captio experience, I broke it down into three elements.</p>

            <h3>Element 1: Instant Launch-to-Input</h3>
            <p>When you launched Captio, the keyboard appeared instantly and text input was ready. There was no splash screen followed by a home screen where you then tap a "compose" button. Launch equals input. We call the time from launch to text input readiness <strong>Time-to-Text</strong>. Captio's felt like under 0.5 seconds.</p>

            <h3>Element 2: Instant Clear After Send</h3>
            <p>When you tapped send, the screen cleared immediately. No staring at a "Sending..." progress bar. The moment your memo disappeared, you felt the reassurance of "it's sent" and moved on. We call the time from tapping send to UI clearing <strong>Send-to-Reset</strong>. Our target is under 150ms.</p>

            <h3>Element 3: Nothing Unnecessary</h3>
            <p>Folders, tags, rich text, markdown support -- Captio had none of these. Just a text field and a send button. This decisiveness brought cognitive load close to zero. An app where you never have to think about "what should I do." That was Captio.</p>

            <p>Recreating these three elements with modern iOS development. That's the mission of "Simple Memo (Captio-style)."</p>
          </section>

          <!-- Section 2 -->
          <section id="en-section2">
            <h2>2. Architecture: Why UIKit Instead of SwiftUI</h2>
            <p>Choosing UIKit over SwiftUI in 2026 iOS development might seem unorthodox. But our top priority was clear -- <strong>Time-to-Text under 500ms</strong>.</p>

            <p>SwiftUI's `body` re-evaluation, `StateObject` initialization, `@Environment` resolution -- these overheads are negligible in typical app development, but not when you need "instant launch-to-input." We wanted to focus the text field even 1ms faster.</p>

            <p>So we adopted <strong>direct UIKit construction without Storyboard</strong>.</p>

            <p>We create the window in SceneDelegate and set ComposeViewController directly as the rootViewController. We even skip Storyboard parsing.</p>

<pre><code>// SceneDelegate.swift
func scene(_ scene: UIScene,
           willConnectTo session: UISceneSession,
           options connectionOptions: UIScene.ConnectionOptions) {
    guard let windowScene = (scene as? UIWindowScene) else { return }
    let window = UIWindow(windowScene: windowScene)
    window.rootViewController = ComposeViewController()
    window.makeKeyAndVisible()
    self.window = window
}</code></pre>

            <p>Then in ComposeViewController's `viewDidAppear`, we immediately focus the text view.</p>

<pre><code>// ComposeViewController.swift
override func viewDidAppear(_ animated: Bool) {
    super.viewDidAppear(animated)
    textView.becomeFirstResponder()
}</code></pre>

            <p>These two pieces of code alone create the shortest path from launch to keyboard display.</p>

            <p>Real device measurements: <strong>200-300ms</strong>. Well below our 500ms target. Trying to achieve the same with SwiftUI, we found that `@FocusState` delays and body re-evaluation timing made it difficult to consistently stay under 500ms.</p>

            <p>UIKit may be "old." But it's "fast." On this single point, UIKit remains the best choice.</p>
          </section>

          <!-- Section 3 -->
          <section id="en-section3">
            <h2>3. Achieving "Send and Clear" in 150 Milliseconds</h2>
            <p>To recreate Captio's "send and it's gone" experience, the most critical design decision was to <strong>completely decouple the send animation and UI clear from the network response</strong>.</p>

            <p>A typical app's send flow looks like this:</p>
            <ol>
              <li>Tap the send button</li>
              <li>Show a loading indicator</li>
              <li>Wait for the server response</li>
              <li>Clear UI on success, show error on failure</li>
            </ol>

            <p>In this flow, network latency directly becomes UI latency. Our flow works differently:</p>
            <ol>
              <li>Tap the send button</li>
              <li><strong>Immediately</strong> clear the UI (animation: 0.25s)</li>
              <li>Send via network in the background</li>
              <li>Success: silently remove from Outbox / Failure: retry in background</li>
            </ol>

<pre><code>// ComposeViewController.swift
private func performSendAnimation() {
    UIView.animate(withDuration: 0.25,
                   delay: 0,
                   options: .curveEaseOut) {
        self.textView.alpha = 0
        self.subjectField.alpha = 0
    } completion: { _ in
        self.textView.text = ""
        self.subjectField.text = ""
        self.textView.alpha = 1
        self.subjectField.alpha = 1
        self.textView.becomeFirstResponder()
    }
}</code></pre>

            <p>For the user, the moment they tap send, the memo "vanishes" and they're ready to write the next one. Network success or failure is handled invisibly in the background.</p>

            <p>"But what if the send fails?" -- that question is answered by the Outbox architecture in the next section.</p>
          </section>

          <!-- Section 4 -->
          <section id="en-section4">
            <h2>4. Zero Message Loss: The Outbox Architecture</h2>
            <p>Decoupling the send UI from the network response means that "the UI cleared but the email actually failed to send" could happen. This is absolutely unacceptable. A user thinking they sent a memo that was never actually delivered -- this is a fatal loss of trust for a memo app.</p>

            <p>That's why we adopted the <strong>Outbox pattern</strong>.</p>

            <p>The message send flow works as follows:</p>
            <ol>
              <li><strong>Tap send</strong>: Save the message to the Outbox (local storage) with AES-GCM encryption</li>
              <li><strong>UI clear</strong>: performSendAnimation immediately clears the screen</li>
              <li><strong>Background send</strong>: Retrieve the message from the Outbox and send to the Relay API</li>
              <li><strong>Success</strong>: Delete the message from the Outbox</li>
              <li><strong>Failure</strong>: Retry with exponential backoff (1s, 2s, 4s, 8s...)</li>
              <li><strong>Offline</strong>: Monitor connectivity with NWPathMonitor, auto-resend when restored</li>
            </ol>

            <p>The critical point is that <strong>the message is saved to the Outbox before the network send</strong>. This means even if the app crashes suddenly or the device loses power, the message is never lost.</p>

            <p>Messages stored in the Outbox are protected with AES-GCM encryption using CryptoKit. Encryption keys are stored in the Keychain, inaccessible from outside the app's sandbox.</p>

<pre><code>// OutboxManager.swift
func enqueue(message: OutboxMessage) throws {
    let key = try KeychainHelper.getOrCreateSymmetricKey()
    let sealedBox = try AES.GCM.seal(
        message.plainData,
        using: key
    )
    let encrypted = EncryptedOutboxEntry(
        id: message.id,
        sealedData: sealedBox.combined!,
        createdAt: Date(),
        retryCount: 0
    )
    try persistenceStore.save(encrypted)
}</code></pre>

            <p>Furthermore, everything is implemented in-house, resulting in <strong>zero external library dependencies</strong>. CryptoKit, NWPathMonitor, URLSession -- all Apple-native frameworks. Being free from third-party library version management and security audits is a significant advantage for a small team.</p>
          </section>

          <!-- Section 5 -->
          <section id="en-section5">
            <h2>5. Relay API: Breaking Free from Gmail Dependency</h2>
            <p>Captio originally sent emails through users' Gmail accounts. However, changes in Google's OAuth requirements and API restrictions made this approach unsustainable.</p>

            <p>We chose a <strong>Cloudflare Workers + Resend API</strong> architecture.</p>

            <p>Cloudflare Workers is an edge computing platform where code runs at the data center closest to each user. Requests from Japan are processed at Japan's edge, requests from the US at the US edge. This virtually eliminates the cold start problem compared to traditional serverless platforms (AWS Lambda, etc.).</p>

            <p>For email delivery, we use the Resend API. Resend is a developer-friendly email API offering high deliverability and reliability.</p>

            <h3>Email Verification Flow</h3>
            <p>When users set their destination email address, a 6-digit verification code is sent for email verification. This prevents unauthorized sending to third-party email addresses.</p>

            <h3>Multi-Layer Rate Limiting</h3>
            <p>To prevent abuse, we implement multi-layer rate limiting.</p>

<pre><code>// Cloudflare Worker - Rate Limit Configuration
const RATE_LIMITS = {
  devicePerMinute: 30,    // 30 per minute per device
  devicePerDay: 200,      // 200 per day per device
  ipPerHour: 120,         // 120 per hour per IP
  globalPerDay: 300       // 300 per day globally (adjustable)
};</code></pre>

            <p>By applying rate limits at three layers -- device, IP, and global -- we can block both single device runaway and botnet attacks.</p>

            <h3>Idempotency Guarantee</h3>
            <p>To prevent duplicate sends due to network instability, each message is assigned a UUID, and the Relay API performs duplicate checking. If the same UUID is resent, subsequent attempts return a success response without actually sending the email. Combined with the Outbox pattern's retry mechanism, this ensures users never receive the same memo twice.</p>
          </section>

          <!-- Section 6 -->
          <section id="en-section6">
            <h2>6. Today's Work: Eliminating Small Annoyances One by One</h2>
            <p>Much of Day 1's implementation work was spent redesigning the star rating dialog. App Store ratings are an app's lifeline, but you shouldn't ask for ratings in a way that damages the user experience.</p>

            <h3>Redesigned Display Conditions</h3>
            <p>The star rating dialog display conditions were set as follows:</p>
            <ul>
              <li><strong>Shows every 100 sends</strong>: Only displayed to users who have used the app extensively</li>
              <li><strong>Minimum 14-day interval</strong>: At least 14 days must have passed since the last display</li>
              <li><strong>30 days after dismiss</strong>: If the user dismisses it, it won't reappear for 30 days</li>
            </ul>

            <h3>Star Icon Tap Area Fix</h3>
            <p>Apple's Human Interface Guidelines recommend a minimum touch target size of 44x44pt. The star icon tap areas didn't meet this standard, so we fixed it.</p>

<pre><code>// StarRatingView.swift
private func createStarButton() -> UIButton {
    let button = UIButton(type: .custom)
    button.translatesAutoresizingMaskIntoConstraints = false
    NSLayoutConstraint.activate([
        button.widthAnchor.constraint(greaterThanOrEqualToConstant: 44),
        button.heightAnchor.constraint(greaterThanOrEqualToConstant: 44)
    ])
    return button
}</code></pre>

            <h3>Star Icon Distortion Fix</h3>
            <p>Star icons were being distorted due to UIStackView's `.fillEqually` distribution. Fixed by setting `contentMode` to `.scaleAspectFit` and changing the StackView distribution to `.equalSpacing`.</p>

            <h3>Post-Rating Flow</h3>
            <ul>
              <li><strong>5 stars</strong>: Navigate to the App Store review screen (`SKStoreReviewController`)</li>
              <li><strong>4 stars and below</strong>: Quietly display a "Thank you" toast and close. Don't funnel negative reviews to the App Store.</li>
            </ul>
          </section>

          <!-- Section 7 -->
          <section id="en-section7">
            <h2>7. Fixing History Status Display Inconsistencies</h2>
            <p>In the send history screen (History), I noticed a bug. Some messages showed "sending" status indefinitely even though delivery had already completed.</p>

            <p>After investigating, I found the issue in the status update logic. The previous implementation used the message's text content as the key for status updates. However, when the same memo content is sent multiple times, text-based lookup can't identify the correct message.</p>

            <p>The fix was straightforward. We changed from text-based lookup to <strong>ID-based status updates</strong>. Since each message is assigned a UUID when saved to the Outbox, we use this ID to update History status.</p>

<pre><code>// HistoryManager.swift
// Before: Text-based lookup (cause of the bug)
// func updateStatus(forText text: String, status: SendStatus)

// After: ID-based status update
func updateStatus(forMessageId id: UUID, status: SendStatus) {
    guard let index = entries.firstIndex(where: { $0.messageId == id }) else {
        return
    }
    entries[index].status = status
    persistEntries()
}</code></pre>

            <p>With this fix, even when sending the same memo content multiple times, each message's status is displayed correctly.</p>
          </section>

          <!-- Section 8 -->
          <section id="en-section8">
            <h2>8. An Obsessive Commitment to Privacy</h2>
            <p>Private information gets written into memo apps. Passwords, personal concerns, business ideas -- we can't predict what users will write. That's exactly why privacy protection should be not just "adequate" but "excessive" -- that level is just right.</p>

            <h3>Privacy Overlay in App Switcher</h3>
            <p>iOS's app switcher shows app screens as thumbnails. To eliminate the risk of third parties seeing memo content, we display a privacy overlay when the app transitions to the background.</p>

            <h3>Ephemeral URLSession</h3>
            <p>A standard URLSession saves cache, cookies, and authentication data to disk. We use `URLSessionConfiguration.ephemeral` to ensure none of this information persists on disk. This eliminates any risk of memo content remaining as cached data in storage.</p>

            <h3>Sanitized Logging</h3>
            <p>Debug logs during development require careful attention. A seemingly harmless practice like "logging the content of sent memos" can become a security hole. Our policy is clear:</p>
            <ul>
              <li>Memo content is <strong>never logged, even in DEBUG builds</strong></li>
              <li>Error logs use <strong>only `type(of: error)`</strong>, never `localizedDescription`</li>
              <li>Reason: `localizedDescription` may contain user input</li>
            </ul>

<pre><code>// NetworkManager.swift
// BAD: Logging error details
// Logger.error("Send failed: \(error.localizedDescription)")

// GOOD: Logging only the error type
Logger.error("Send failed: \(type(of: error))")</code></pre>

            <p>It might seem paranoid. But to earn users' trust in a memo app, we believe this level of paranoia is necessary.</p>
          </section>

          <!-- Section 9 -->
          <section id="en-section9">
            <h2>9. 10 Languages: Reaching Captio Users Worldwide</h2>
            <p>Captio had users worldwide, centered around English-speaking countries. To reach those former users with "Simple Memo (Captio-style)," we supported 10 languages from the initial release.</p>

            <p>Supported languages: Japanese, English, Spanish, French, German, Italian, Portuguese, Korean, Chinese (Simplified), and Arabic.</p>

            <p>The technical challenge of <strong>Arabic RTL (Right-to-Left) support</strong> was particularly notable. Not just text direction, but the entire UI layout needs to be mirrored. By consistently using `leading`/`trailing` constraints in Auto Layout, we achieve a natural layout in RTL environments.</p>

            <h3>In-App Language Switching</h3>
            <p>In addition to iOS 16+'s built-in per-app language settings, we implemented our own language switching mechanism. When the language changes, the ViewController is replaced with a `cross-dissolve` transition for a smooth switching experience.</p>

<pre><code>// LanguageManager.swift
func applyLanguageChange() {
    guard let window = UIApplication.shared.connectedScenes
        .compactMap({ $0 as? UIWindowScene })
        .first?.windows.first else { return }

    let newVC = ComposeViewController()
    newVC.view.frame = window.bounds
    UIView.transition(with: window,
                      duration: 0.3,
                      options: .transitionCrossDissolve,
                      animations: {
        window.rootViewController = newVC
    })
}</code></pre>
          </section>

          <!-- Section 10 -->
          <section id="en-section10">
            <h2>10. Today's Lesson: Product Design Is About Trust</h2>
            <p>Finishing Day 1, what strikes me is that the essence of this product is designing for trust.</p>

            <p>Let me summarize the technical metrics:</p>
            <ul>
              <li><strong>Time-to-Text</strong>: Under 500ms (measured 200-300ms)</li>
              <li><strong>Send-to-Reset</strong>: Under 150ms</li>
              <li><strong>Message loss</strong>: Zero (Outbox pattern)</li>
              <li><strong>Encryption</strong>: AES-GCM (CryptoKit)</li>
              <li><strong>External library dependencies</strong>: Zero</li>
            </ul>

            <p>But all these metrics converge on a single goal: trust.</p>

            <p>Fast launch: the trust that "I can always write immediately."<br>
            Send and clear: the trust that "it's been processed."<br>
            Zero message loss: the trust that "it will absolutely be delivered."<br>
            Encryption: the trust that "nobody can see it."</p>

            <p>Captio wasn't loved because its features were superior. It was loved because it had meticulously polished an experience you could use with complete trust. That's what we want to carry forward.</p>
          </section>

          <!-- Section 11 -->
          <section id="en-section11">
            <h2>11. Day 2 Preview</h2>
            <p>In Day 2, we plan to tackle the following themes:</p>
            <ul>
              <li><strong>Send animation refinement</strong>: Moving beyond the current 0.25s fade-out to a more pleasant animation</li>
              <li><strong>History status update timing optimization</strong>: Comparing real-time updates vs. batch updates</li>
              <li><strong>Is the success toast even needed?</strong>: Considering the option of "not showing" any send success feedback</li>
            </ul>
            <p>Aiming for Captio's "nothing there" decisiveness. On to Day 2.</p>
          </section>

        </div>
      </div>

      <!-- ======================== -->
      <!-- RELATED TOPICS (shared)  -->
      <!-- ======================== -->
      <div class="related-topics">
        <h2>
          <span data-lang="ja">関連トピック深掘り</span>
          <span data-lang="en">Related Deep Dives</span>
        </h2>
        <div class="related-grid">
          <a href="/devlog/captio-alternative.html" class="related-card">
            <div class="related-card__title">
              <span data-lang="ja">Captio代替アプリを作った理由</span>
              <span data-lang="en">Why We Built a Captio Alternative</span>
            </div>
            <div class="related-card__desc">
              <span data-lang="ja">Captioがサービス終了した後、なぜ自分で代替アプリを作ることにしたのか。体験の3要素を分解。</span>
              <span data-lang="en">After Captio shut down, why we decided to build our own. Deconstructing the 3 elements of the experience.</span>
            </div>
          </a>
          <a href="/devlog/uikit-vs-swiftui.html" class="related-card">
            <div class="related-card__title">
              <span data-lang="ja">UIKit vs SwiftUI：起動速度のための選択</span>
              <span data-lang="en">UIKit vs SwiftUI: Choosing for Launch Speed</span>
            </div>
            <div class="related-card__desc">
              <span data-lang="ja">2026年にUIKitを選んだ理由。Time-to-Text 500ms以下を実現するアーキテクチャ設計。</span>
              <span data-lang="en">Why UIKit in 2026. Architecture design to achieve Time-to-Text under 500ms.</span>
            </div>
          </a>
          <a href="/devlog/outbox-architecture.html" class="related-card">
            <div class="related-card__title">
              <span data-lang="ja">Outboxアーキテクチャ：取りこぼしゼロ設計</span>
              <span data-lang="en">Outbox Architecture: Zero Message Loss</span>
            </div>
            <div class="related-card__desc">
              <span data-lang="ja">送信即UIクリア、でもメッセージは絶対に失われない。AES-GCM暗号化Outboxパターンの全容。</span>
              <span data-lang="en">Instant UI clear on send, but messages never lost. The full AES-GCM encrypted Outbox pattern.</span>
            </div>
          </a>
          <a href="/devlog/relay-api-design.html" class="related-card">
            <div class="related-card__title">
              <span data-lang="ja">Relay API：Cloudflare Workersでメール送信基盤を構築</span>
              <span data-lang="en">Relay API: Email Infrastructure on Cloudflare Workers</span>
            </div>
            <div class="related-card__desc">
              <span data-lang="ja">Gmail API依存からの脱却。エッジコンピューティングで世界中から数十msでメール送信。</span>
              <span data-lang="en">Breaking free from Gmail API. Edge computing for global email delivery in milliseconds.</span>
            </div>
          </a>
          <a href="/devlog/privacy-first-design.html" class="related-card">
            <div class="related-card__title">
              <span data-lang="ja">プライバシーファースト設計：偏執的なこだわり</span>
              <span data-lang="en">Privacy-First Design: Obsessive Attention to Detail</span>
            </div>
            <div class="related-card__desc">
              <span data-lang="ja">ephemeral URLSession、プライバシーオーバーレイ、ログ無害化。メモアプリだからこそ過剰なくらいがちょうどいい。</span>
              <span data-lang="en">Ephemeral URLSession, privacy overlay, sanitized logs. For a memo app, being overly cautious is just right.</span>
            </div>
          </a>
        </div>
      </div>

    </div>
  </main>

  <footer class="footer">
    <div class="container">
      <nav class="footer__links">
        <a href="/" class="footer__link">
          <span data-lang="ja">ホーム</span>
          <span data-lang="en">Home</span>
        </a>
        <a href="/devlog/" class="footer__link">
          <span data-lang="ja">開発日誌</span>
          <span data-lang="en">Dev Log</span>
        </a>
        <a href="/terms.html" class="footer__link">
          <span data-lang="ja">利用規約</span>
          <span data-lang="en">Terms</span>
        </a>
        <a href="/privacy.html" class="footer__link">
          <span data-lang="ja">プライバシーポリシー</span>
          <span data-lang="en">Privacy</span>
        </a>
        <a href="/contact.html" class="footer__link">
          <span data-lang="ja">お問い合わせ</span>
          <span data-lang="en">Contact</span>
        </a>
      </nav>
      <p class="footer__copyright">
        &copy; 2026
        <span data-lang="ja">Capito式シンプルメモ</span>
        <span data-lang="en">Simple Memo - Captio-style</span>.
        All rights reserved.
      </p>
    </div>
  </footer>

  <script src="/js/lang.js"></script>
</body>
</html>
