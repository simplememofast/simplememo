<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="noindex, nofollow">
  <title>TikTok Slide Builder</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@500;800&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    :root {
      --bg: #000; --surface: #0d1117; --accent: #6ab4ff; --accent2: #4fc3f7;
      --green: #3fb950; --red: #f85149; --yellow: #d29922;
      --text: #fff; --text2: rgba(255,255,255,.7); --text3: rgba(255,255,255,.45);
      --border: rgba(100,160,220,.12); --border2: rgba(100,180,255,.25);
      --r: 10px; --font: 'Inter',-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;
    }
    *{box-sizing:border-box;margin:0;padding:0}
    body{font-family:var(--font);background:var(--bg);color:var(--text);min-height:100dvh}

    .hdr{padding:12px 20px;border-bottom:1px solid var(--border);display:flex;align-items:center;justify-content:space-between;position:sticky;top:0;background:rgba(0,0,0,.92);backdrop-filter:blur(12px);z-index:50}
    .hdr h1{font-size:.88rem;font-weight:600;color:var(--text2)} .hdr h1 b{color:var(--accent)}

    .main{padding:20px;max-width:1100px;margin:0 auto}

    .card{background:var(--surface);border:1px solid var(--border);border-radius:var(--r);margin-bottom:16px;overflow:hidden}
    .card-h{padding:10px 14px;border-bottom:1px solid var(--border);font-size:.8rem;font-weight:600;color:var(--text2);display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap}

    .card-b{padding:14px}

    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}

    select,button,input[type=number]{font-family:var(--font);font-size:.8rem;border-radius:6px;border:1px solid var(--border);background:var(--bg);color:var(--text);padding:7px 12px;cursor:pointer}
    input[type=number]{width:60px;cursor:text}
    select:focus,button:focus,input:focus{outline:none;border-color:var(--accent)}
    .btn-accent{background:var(--accent);color:#000;font-weight:700;border:none;padding:8px 22px}
    .btn-accent:hover{background:var(--accent2)}
    .btn-accent:disabled{opacity:.5;cursor:wait}
    .btn-sm{padding:4px 10px;font-size:.72rem}
    .btn-outline{background:transparent;color:var(--text2)}
    .btn-outline:hover{border-color:var(--border2);color:var(--text)}
    .btn-green{background:var(--green);color:#000;border:none}
    .btn-dl{background:rgba(63,185,80,.12);color:var(--green);border:1px solid rgba(63,185,80,.3)}

    label{font-size:.78rem;color:var(--text3)}
    .check-row{display:flex;align-items:center;gap:6px}
    .check-row input[type=checkbox]{accent-color:var(--accent)}

    .grid{display:grid;grid-template-columns:repeat(6,1fr);gap:8px}
    @media(max-width:900px){.grid{grid-template-columns:repeat(3,1fr)}}
    @media(max-width:500px){.grid{grid-template-columns:repeat(2,1fr)}}

    .slot{background:var(--bg);border:1px solid var(--border);border-radius:8px;overflow:hidden;position:relative}
    .slot:hover{border-color:var(--border2)}
    .slot-n{position:absolute;top:4px;left:4px;background:rgba(0,0,0,.7);color:var(--text3);font-size:.6rem;font-weight:700;padding:1px 6px;border-radius:3px;z-index:2}
    .slot-img{width:100%;aspect-ratio:9/16;display:flex;align-items:center;justify-content:center;color:var(--text3);font-size:.7rem;overflow:hidden}
    .slot-img img{width:100%;height:100%;object-fit:cover}
    .slot-meta{padding:6px 8px;border-top:1px solid var(--border);font-size:.6rem;color:var(--text3);display:flex;justify-content:space-between;align-items:center}

    .log{background:var(--bg);border:1px solid var(--border);border-radius:6px;padding:10px;font-family:'SF Mono','Fira Code',monospace;font-size:.68rem;color:var(--text3);max-height:160px;overflow-y:auto;white-space:pre-wrap;word-break:break-all;line-height:1.6}
    .log .ok{color:var(--green)} .log .err{color:var(--red)} .log .i{color:var(--accent)} .log .w{color:var(--yellow)}

    .spinner{display:inline-block;width:14px;height:14px;border:2px solid var(--text3);border-top-color:var(--accent);border-radius:50%;animation:spin .6s linear infinite;vertical-align:middle;margin-right:6px}
    @keyframes spin{to{transform:rotate(360deg)}}

    .status{font-size:.75rem;color:var(--text3);margin-top:8px}
    .badge{display:inline-block;padding:1px 7px;border-radius:4px;font-size:.65rem;font-weight:600;margin-left:6px}
    .badge-ok{background:rgba(63,185,80,.15);color:var(--green)}
    .badge-warn{background:rgba(210,153,34,.15);color:var(--yellow)}
    .badge-err{background:rgba(248,81,73,.15);color:var(--red)}
    .warn-badges{padding:4px 8px;display:flex;gap:4px;flex-wrap:wrap}
    .warn-badge{display:inline-block;padding:1px 6px;border-radius:3px;font-size:.58rem;font-weight:600}
    .warn-badge-warn{background:rgba(210,153,34,.18);color:var(--yellow)}
    .warn-badge-err{background:rgba(248,81,73,.18);color:var(--red)}
    .warn-summary{font-size:.72rem;color:var(--yellow);margin-top:6px}
  </style>
</head>
<body>

<header class="hdr">
  <h1><b>TikTok</b> Slide Builder</h1>
  <span id="timer" style="font-size:.75rem;color:var(--text3)"></span>
</header>

<div class="main">

  <!-- Controls -->
  <div class="card">
    <div class="card-h">Generate</div>
    <div class="card-b">
      <div class="row">
        <div>
          <label>Variant</label><br>
          <select id="variant">
            <option value="W" selected>W — 仕事勢SOP (12 patterns)</option>
            <option value="A">A — 忘れる系 (100 patterns)</option>
            <option value="B">B — 先延ばし系</option>
            <option value="C">C — 忙しい仕事人</option>
          </select>
        </div>
        <div>
          <label>Pattern Mode</label><br>
          <select id="pattern-mode">
            <option value="random" selected>Random</option>
            <option value="tag">Tag-based</option>
            <option value="seeded">Seeded</option>
          </select>
        </div>
        <div id="tag-select-wrap" style="display:none">
          <label>Category</label><br>
          <select id="tag-select">
            <option value="">All</option>
          </select>
        </div>
        <div id="seed-wrap" style="display:none">
          <label>Pattern ID</label><br>
          <input type="text" id="seed-input" placeholder="W001" style="width:80px;font-family:var(--font);font-size:.8rem;border-radius:6px;border:1px solid var(--border);background:var(--bg);color:var(--text);padding:7px 12px">
        </div>
        <div>
          <label>Diversity</label><br>
          <select id="diversity">
            <option value="low">Low (0.2)</option>
            <option value="mid" selected>Mid (0.4)</option>
            <option value="high">High (0.6)</option>
          </select>
        </div>
        <div>
          <label>Avoid Recent</label><br>
          <input type="number" id="avoid-recent" value="20" min="0" max="99">
        </div>
        <div class="check-row" style="margin-top:14px">
          <input type="checkbox" id="hook-swap" checked><label for="hook-swap">Hook Swap</label>
        </div>
        <div class="check-row" style="margin-top:14px">
          <input type="checkbox" id="brand" checked><label for="brand">Brand Footer</label>
        </div>
        <div class="check-row" style="margin-top:14px">
          <input type="checkbox" id="ab-mode"><label for="ab-mode">A/B Copy Mode</label>
        </div>
        <button class="btn-accent" id="gen-btn" style="margin-top:14px">Generate 6 Slides</button>
      </div>
    </div>
  </div>

  <!-- Preview -->
  <div class="card">
    <div class="card-h">
      <span>Slides Preview <span id="pattern-badge"></span></span>
      <div class="row" id="dl-row" style="display:none">
        <button class="btn-sm btn-dl" id="zip-btn">ZIP Download</button>
        <button class="btn-sm btn-outline" id="log-btn">Export Log</button>
        <button class="btn-sm btn-green" id="tiktok-btn">TikTokへ送る</button>
      </div>
    </div>
    <div class="card-b">
      <div class="grid" id="grid"></div>
      <div class="status" id="status"></div>
    </div>
  </div>

  <!-- Log -->
  <div class="card">
    <div class="card-h">Log</div>
    <div class="card-b">
      <div class="log" id="log">待機中…</div>
    </div>
  </div>

</div>

<script>
(function(){
  var $ = function(id){ return document.getElementById(id) };
  var logEl = $('log');
  var gridEl = $('grid');
  var currentPlan = null;
  var currentBlobs = [];
  var currentPattern = null;
  var currentSlides = null; // slides after hook swap

  // ── Pattern data ──────────────────────────────────────────────
  var patternLibrary = {};   // { W: { patterns: [...], ... }, A: {...} }
  var hooksLibrary = null;
  var FALLBACK_SCRIPTS = {
    B: [
      ["I nod. I forget.", "Every time."],
      ["To-do apps are", "where tasks go to die."],
      ["So I email the task.", "Instantly."],
      ["Now it stares back", "in my inbox."],
      ["No system.", "Just friction."],
      ["Be honest\u2014", "notes app or inbox?"]
    ],
    C: [
      ["If it's not in my inbox,", "it's gone."],
      ["Slack scrolls.", "Notes get buried."],
      ["Email doesn't.", ""],
      ["One tap,", "one reminder."],
      ["Boring on purpose.", "That's why it works."],
      ["What actually works", "for you?"]
    ]
  };

  // ── Logging ──────────────────────────────────────────────────
  function log(cls, msg){
    if(logEl.textContent==='待機中…') logEl.textContent='';
    var d = document.createElement('div');
    d.className = cls;
    d.textContent = '['+new Date().toLocaleTimeString()+'] '+msg;
    logEl.appendChild(d);
    logEl.scrollTop = logEl.scrollHeight;
  }

  // ── Recent history (localStorage) ─────────────────────────────
  var HISTORY_KEY = 'tiktok_pattern_history';
  function getHistory(){
    try { return JSON.parse(localStorage.getItem(HISTORY_KEY)) || []; } catch(e){ return []; }
  }
  function addToHistory(patternId){
    var h = getHistory();
    h.unshift(patternId);
    if(h.length > 200) h = h.slice(0, 200);
    localStorage.setItem(HISTORY_KEY, JSON.stringify(h));
  }

  // ── Hook history (localStorage) ───────────────────────────────
  var HOOK_HISTORY_KEY = 'tiktok_hook_history';
  function getHookHistory(){
    try { return JSON.parse(localStorage.getItem(HOOK_HISTORY_KEY)) || []; } catch(e){ return []; }
  }
  function addToHookHistory(hookId){
    var h = getHookHistory();
    h.unshift(hookId);
    if(h.length > 200) h = h.slice(0, 200);
    localStorage.setItem(HOOK_HISTORY_KEY, JSON.stringify(h));
  }

  // ── Load pattern library ──────────────────────────────────────
  async function loadPatterns(variant){
    if(patternLibrary[variant]) return patternLibrary[variant];
    try {
      var res = await fetch('patterns/'+variant+'.json');
      if(!res.ok) return null;
      var data = await res.json();
      patternLibrary[variant] = data;
      log('ok', 'Loaded '+data.patterns.length+' patterns for variant '+variant);
      // Populate categories dynamically
      populateCategories(data);
      return data;
    } catch(e){
      log('w', 'No pattern library for variant '+variant+', using fallback');
      return null;
    }
  }

  // ── Load hooks ────────────────────────────────────────────────
  async function loadHooks(){
    try {
      var res = await fetch('patterns/hooks.json');
      if(!res.ok) return null;
      hooksLibrary = await res.json();
      log('ok', 'Loaded '+hooksLibrary.hooks.length+' hook alternatives');
      return hooksLibrary;
    } catch(e){
      log('w', 'No hooks library found');
      return null;
    }
  }

  // ── Populate categories from library ──────────────────────────
  function populateCategories(lib){
    var sel = $('tag-select');
    sel.innerHTML = '<option value="">All</option>';
    if(lib && lib.categories){
      lib.categories.forEach(function(cat){
        var opt = document.createElement('option');
        opt.value = cat;
        opt.textContent = cat;
        sel.appendChild(opt);
      });
    } else if(lib && lib.patterns){
      // Infer categories from patterns
      var cats = {};
      lib.patterns.forEach(function(p){ if(p.category) cats[p.category]=1; });
      Object.keys(cats).sort().forEach(function(cat){
        var opt = document.createElement('option');
        opt.value = cat;
        opt.textContent = cat;
        sel.appendChild(opt);
      });
    }
  }

  // ── Hook category weights ──────────────────────────────────────
  var HOOK_CATEGORY_WEIGHTS = { pain: 3.0, gain: 2.5, contrarian: 2.0, identity: 1.5, 'quiet-luxury': 1.0 };

  // ── Hook swap (with category weighting) ───────────────────────
  function swapHook(slides, variant, preferredCategory){
    if(!hooksLibrary || !hooksLibrary.hooks || hooksLibrary.hooks.length === 0){
      return { slides: slides, hookId: null };
    }
    var pool = hooksLibrary.hooks;
    if(variant){
      var variantHooks = pool.filter(function(h){ return h.variant === variant; });
      if(variantHooks.length > 0) pool = variantHooks;
    }
    if(preferredCategory){
      var catHooks = pool.filter(function(h){ return h.category === preferredCategory; });
      if(catHooks.length > 0) pool = catHooks;
    }
    var recentHooks = getHookHistory().slice(0, 10);
    var available = pool.filter(function(h){ return recentHooks.indexOf(h.id) === -1; });
    if(available.length === 0) available = pool;

    // Weighted random by category
    var totalWeight = 0;
    available.forEach(function(h){ totalWeight += (HOOK_CATEGORY_WEIGHTS[h.category] || 1); });
    var r = Math.random() * totalWeight;
    var pick = available[0];
    for(var i = 0; i < available.length; i++){
      r -= (HOOK_CATEGORY_WEIGHTS[available[i].category] || 1);
      if(r <= 0){ pick = available[i]; break; }
    }

    addToHookHistory(pick.id);
    var newSlides = slides.map(function(s){ return s.slice(); });
    newSlides[0] = pick.text;
    return { slides: newSlides, hookId: pick.id, hookTone: pick.tone, hookCategory: pick.category };
  }

  // ── Slide rules validation ─────────────────────────────────────
  function validateSlideRules(slides, slideRules){
    if(!slideRules) return [];
    var warnings = [];
    for(var i = 0; i < slides.length; i++){
      var rule = slideRules['slide' + (i + 1)];
      if(!rule) continue;
      var text = slides[i].filter(function(l){ return l; }).join(' ');
      var chars = text.length;
      var words = text.split(/\s+/).filter(function(w){ return w.length > 0; }).length;
      var lineCount = slides[i].filter(function(l){ return l && l.length > 0; }).length;

      if(rule.maxChars && chars > rule.maxChars){
        warnings.push({ slide: i + 1, type: 'chars', value: chars, max: rule.maxChars });
      }
      if(rule.maxWords && words > rule.maxWords){
        warnings.push({ slide: i + 1, type: 'words', value: words, max: rule.maxWords });
      }
      if(rule.maxLines && lineCount > rule.maxLines){
        warnings.push({ slide: i + 1, type: 'lines', value: lineCount, max: rule.maxLines });
      }
    }
    return warnings;
  }

  // ── NG Filter ─────────────────────────────────────────────────
  var NG_STOP_WORDS = ["i","a","an","the","is","it","to","my","in","of","and","or","but","not","no","do","be","so","that","this","for","you","your","just","don","t","s","re","ll","ve","m","d"];

  function ngFilter(slides){
    var issues = [];
    // Word repetition across slides
    var wordSlideCount = {};
    for(var si=0; si<slides.length; si++){
      var text = slides[si].join(" ").toLowerCase().replace(/[^a-z0-9\s]/g, "");
      var words = text.split(/\s+/).filter(function(w){ return w.length > 2 && NG_STOP_WORDS.indexOf(w) === -1; });
      var seen = {};
      for(var wi=0; wi<words.length; wi++){
        if(!seen[words[wi]]){
          seen[words[wi]] = true;
          wordSlideCount[words[wi]] = (wordSlideCount[words[wi]] || 0) + 1;
        }
      }
    }
    for(var w in wordSlideCount){
      if(wordSlideCount[w] >= 3) issues.push({ type: "word_repeat", word: w, count: wordSlideCount[w] });
    }
    // Long hook check
    var hookWords = slides[0].join(" ").split(/\s+/).filter(function(w){ return w.length > 0; }).length;
    if(hookWords > 12) issues.push({ type: "long_hook", words: hookWords });
    return issues;
  }

  // ── Similarity: Jaccard on words ──────────────────────────────
  function tokenize(text){
    return text.toLowerCase().replace(/[^a-z0-9\s]/g,'').split(/\s+/).filter(function(w){ return w.length > 1; });
  }

  function jaccardSimilarity(textA, textB){
    var a = tokenize(textA);
    var b = tokenize(textB);
    if(a.length===0 && b.length===0) return 0;
    var setA = {}; a.forEach(function(w){ setA[w]=1; });
    var setB = {}; b.forEach(function(w){ setB[w]=1; });
    var intersection = 0, union = {};
    for(var k in setA){ union[k]=1; if(setB[k]) intersection++; }
    for(var k in setB){ union[k]=1; }
    var unionSize = Object.keys(union).length;
    return unionSize === 0 ? 0 : intersection / unionSize;
  }

  function patternToText(pattern){
    return pattern.slides.map(function(s){ return s.join(' '); }).join(' ');
  }

  // ── Banned/caution word filter ────────────────────────────────
  var DEFAULT_BANNED = [
    "free money","guaranteed","100%","cure","miracle","hack your",
    "doctors hate","secret trick","make money","get rich","no effort",
    "limited time","act now","don't miss","once in a lifetime"
  ];
  var DEFAULT_CAUTION = [
    "download","install","buy","subscribe","sign up","ADHD",
    "depression","anxiety","mental health","disorder",
    "optimize","efficient","important","in conclusion","therefore"
  ];

  function checkSafety(pattern, lib){
    var banned = (lib && lib.bannedWords) || DEFAULT_BANNED;
    var caution = (lib && lib.cautionWords) || DEFAULT_CAUTION;
    var text = patternToText(pattern).toLowerCase();
    var result = { passed: true, bannedHits: [], cautionHits: [], appNameCount: 0 };

    banned.forEach(function(w){
      if(text.indexOf(w.toLowerCase()) !== -1){
        result.bannedHits.push(w);
        result.passed = false;
      }
    });

    caution.forEach(function(w){
      if(text.indexOf(w.toLowerCase()) !== -1){
        result.cautionHits.push(w);
      }
    });

    // Count app name mentions (SimpleMemo, Simple Memo)
    var appRegex = /simple\s*memo/gi;
    var matches = text.match(appRegex);
    result.appNameCount = matches ? matches.length : 0;
    if(result.appNameCount > 1){
      result.passed = false;
      result.bannedHits.push('App name mentioned '+result.appNameCount+' times (max 1)');
    }

    return result;
  }

  // ── Pattern selection algorithm ───────────────────────────────
  function selectPattern(lib, mode, tagFilter, seedId, avoidN, diversityThreshold){
    var patterns = lib.patterns;
    var history = getHistory();
    var recentIds = history.slice(0, avoidN);

    // Filter by mode
    var candidates;
    if(mode === 'seeded' && seedId){
      var found = patterns.filter(function(p){ return p.id === seedId.toUpperCase(); });
      if(found.length > 0) return { pattern: found[0], reason: 'seeded' };
      log('w', 'Pattern '+seedId+' not found, falling back to random');
    }

    if(mode === 'tag' && tagFilter){
      candidates = patterns.filter(function(p){ return p.category === tagFilter; });
      if(candidates.length === 0){
        log('w', 'No patterns for tag '+tagFilter+', using all');
        candidates = patterns;
      }
    } else {
      candidates = patterns;
    }

    // Exclude recent
    var available = candidates.filter(function(p){
      return recentIds.indexOf(p.id) === -1;
    });
    if(available.length === 0){
      log('w', 'All patterns used recently, resetting avoid list');
      available = candidates;
    }

    // Weighted random selection with similarity check
    var totalWeight = 0;
    available.forEach(function(p){ totalWeight += (p.weight || 1); });

    var maxAttempts = Math.min(available.length, 10);
    var recentTexts = [];
    // Build recent texts for similarity
    for(var i=0; i<Math.min(recentIds.length, 5); i++){
      var rp = patterns.filter(function(p){ return p.id === recentIds[i]; })[0];
      if(rp) recentTexts.push(patternToText(rp));
    }

    for(var attempt=0; attempt < maxAttempts; attempt++){
      // Weighted random pick
      var r = Math.random() * totalWeight;
      var acc = 0;
      var pick = available[0];
      for(var j=0; j<available.length; j++){
        acc += (available[j].weight || 1);
        if(acc >= r){ pick = available[j]; break; }
      }

      // Similarity check against recent
      var pickText = patternToText(pick);
      var maxSim = 0;
      for(var k=0; k<recentTexts.length; k++){
        var sim = jaccardSimilarity(pickText, recentTexts[k]);
        if(sim > maxSim) maxSim = sim;
      }

      if(maxSim < diversityThreshold || attempt === maxAttempts - 1){
        return { pattern: pick, reason: mode, similarity: maxSim, attempts: attempt + 1 };
      }
    }

    // Fallback: just pick first available
    return { pattern: available[0], reason: 'fallback', similarity: 1, attempts: maxAttempts };
  }

  // ── Constants ────────────────────────────────────────────────
  var W = 1080, H = 1920;
  var LAYOUTS = ["poster_dark", "caption_subtle", "caption_light"];
  var POSITIONS = [
    "top-left", "top-center", "top-right",
    "bottom-left", "bottom-center", "bottom-right"
  ];
  var CROPS = ["wide", "zoom-in", "left-focus", "right-focus"];

  // ── TikTok safe areas (avoid UI overlay) ───────────────────
  var SAFE_LEFT = 64;
  var SAFE_RIGHT = 120;
  var SAFE_TOP = 140;
  var SAFE_BOTTOM = 280;
  var SAFE_MAX_W = W - SAFE_LEFT - SAFE_RIGHT; // 896

  // ── Band design tokens ─────────────────────────────────────
  var BAND_PAD_X = 40;
  var BAND_PAD_Y = 28;
  var BAND_RADIUS = 16;
  var BAND_MIN_W = 320;
  var MAX_TEXT_LINES = 3;

  // ── Band width templates (3 sizes for consistency) ────────
  var BAND_TEMPLATES = {
    short:  { widthRatio: 0.55, maxChars: 20 },
    medium: { widthRatio: 0.75, maxChars: 40 },
    long:   { widthRatio: 0.95, maxChars: 999 }
  };

  // ── Top position (10% safe area center) ───────────────────
  var TOP_POSITION_Y = 192;

  // Font size steps per slide role (descending)
  var FONT_STEPS = {
    hook: [96, 80, 64, 48],
    body: [76, 64, 52, 42],
    cta:  [68, 56, 46, 38]
  };

  // ── Utility ──────────────────────────────────────────────────
  function shuffle(arr){
    for(var i=arr.length-1;i>0;i--){
      var j=Math.floor(Math.random()*(i+1));
      var tmp=arr[i]; arr[i]=arr[j]; arr[j]=tmp;
    }
    return arr;
  }

  function assignLayouts(){
    return shuffle(["poster_dark","poster_dark","caption_subtle","caption_subtle","caption_light","caption_light"]);
  }

  function assignPositions(){
    var picked=[], available=POSITIONS.slice();
    for(var i=0;i<6;i++){
      var idx=Math.floor(Math.random()*available.length);
      picked.push(available[idx]);
      available.splice(idx,1);
      if(available.length===0) available=POSITIONS.slice();
    }
    return picked;
  }

  function assignCrops(){
    var pool=[];
    while(pool.length<6) pool=pool.concat(shuffle(CROPS.slice()));
    return pool.slice(0,6);
  }

  // ── Crop logic ────────────────────────────────────────────────
  function getCropRegion(srcW, srcH, cropVariant){
    var targetRatio = W/H;
    var extractW, extractH, left, top;

    if(cropVariant==="zoom-in"){
      extractW=Math.round(srcW*0.65);
      extractH=Math.round(extractW/targetRatio);
      if(extractH>srcH*0.65){
        extractH=Math.round(srcH*0.65);
        extractW=Math.round(extractH*targetRatio);
      }
      left=Math.round((srcW-extractW)/2);
      top=Math.round((srcH-extractH)/2);
    } else if(cropVariant==="left-focus"){
      extractH=srcH;
      extractW=Math.round(extractH*targetRatio);
      if(extractW>srcW){ extractW=srcW; extractH=Math.round(srcW/targetRatio); }
      left=0;
      top=Math.round((srcH-extractH)/2);
    } else if(cropVariant==="right-focus"){
      extractH=srcH;
      extractW=Math.round(extractH*targetRatio);
      if(extractW>srcW){ extractW=srcW; extractH=Math.round(srcW/targetRatio); }
      left=Math.max(0,srcW-extractW);
      top=Math.round((srcH-extractH)/2);
    } else {
      var srcRatio=srcW/srcH;
      if(srcRatio>targetRatio){
        extractH=srcH;
        extractW=Math.round(srcH*targetRatio);
        left=Math.round((srcW-extractW)/2);
        top=0;
      } else {
        extractW=srcW;
        extractH=Math.round(srcW/targetRatio);
        left=0;
        top=Math.round((srcH-extractH)/2);
      }
    }

    extractW=Math.min(extractW,srcW-left);
    extractH=Math.min(extractH,srcH-top);
    return {left:left, top:top, width:extractW, height:extractH};
  }

  // ── Preload background images ────────────────────────────────
  var bgImages = [];
  var bgLoaded = 0;

  var BG_VERSION = 2; // bump to bust cache after bg image update

  function preloadBackgrounds(bgTypes, callback){
    bgLoaded = 0;
    bgImages = [];
    var total = 6;
    var cacheBust = '?v=' + BG_VERSION;
    for(var i=0;i<6;i++){
      (function(idx){
        var bgType = (bgTypes && bgTypes[idx]) || 'desk';
        var img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = function(){
          bgImages[idx] = img;
          bgLoaded++;
          if(bgLoaded===total) callback();
        };
        img.onerror = function(){
          // Fallback to desk if type-specific not found
          if(bgType !== 'desk'){
            log('w', 'bg/'+bgType+'/'+(idx+1)+'.jpg not found, fallback to desk');
            var fallback = new Image();
            fallback.crossOrigin = 'anonymous';
            fallback.onload = function(){
              bgImages[idx] = fallback;
              bgLoaded++;
              if(bgLoaded===total) callback();
            };
            fallback.onerror = function(){
              log('err', 'Failed to load bg/'+(idx+1)+'.jpg');
              bgLoaded++;
              if(bgLoaded===total) callback();
            };
            fallback.src = 'bg/'+(idx+1)+'.jpg' + cacheBust;
          } else {
            log('err', 'Failed to load bg/'+(idx+1)+'.jpg');
            bgLoaded++;
            if(bgLoaded===total) callback();
          }
        };
        // Try type-specific first, then default
        if(bgType !== 'desk'){
          img.src = 'bg/'+bgType+'/'+(idx+1)+'.jpg' + cacheBust;
        } else {
          img.src = 'bg/'+(idx+1)+'.jpg' + cacheBust;
        }
      })(i);
    }
  }

  // ── Select band template by total character count ──────────
  function selectBandTemplate(lines){
    var totalChars = lines.filter(function(l){ return l && l.length > 0; }).join('').length;
    if(totalChars <= BAND_TEMPLATES.short.maxChars) return 'short';
    if(totalChars <= BAND_TEMPLATES.medium.maxChars) return 'medium';
    return 'long';
  }

  // ── Balance 2-line text for even width distribution ───────
  function balanceWrapLines(lines, fontSize, maxWidth, measureFn){
    if(lines.length !== 2) return lines;
    var w0 = measureFn(lines[0], fontSize);
    var w1 = measureFn(lines[1], fontSize);
    var diff = Math.abs(w0 - w1);
    var avg = (w0 + w1) / 2;
    if(diff < avg * 0.3) return lines;
    var combined = lines[0] + ' ' + lines[1];
    var words = combined.split(/\s+/);
    if(words.length < 3) return lines;
    var bestSplit = lines;
    var bestDiff = diff;
    for(var i = 1; i < words.length; i++){
      var a = words.slice(0, i).join(' ');
      var b = words.slice(i).join(' ');
      var wa = measureFn(a, fontSize);
      var wb = measureFn(b, fontSize);
      if(wa > maxWidth || wb > maxWidth) continue;
      var d = Math.abs(wa - wb);
      if(d < bestDiff){ bestDiff = d; bestSplit = [a, b]; }
    }
    return bestSplit;
  }

  // ── Get slide role for font sizing ──────────────────────────
  function getSlideRole(slideIndex){
    if(slideIndex === 0) return 'hook';
    if(slideIndex === 5) return 'cta';
    return 'body';
  }

  // ── Get safe area for a position ──────────────────────────
  function getSafeArea(position){
    var x, y, maxW, maxH;
    if(position.indexOf("left")!==-1){
      x = SAFE_LEFT;
      maxW = W - SAFE_LEFT - SAFE_RIGHT - 40; // extra margin from right UI
    } else if(position.indexOf("right")!==-1){
      x = SAFE_LEFT + 40;
      maxW = W - SAFE_LEFT - SAFE_RIGHT - 40;
    } else {
      x = SAFE_LEFT;
      maxW = SAFE_MAX_W;
    }
    if(position.indexOf("top")===0){
      y = SAFE_TOP;
      maxH = H - SAFE_TOP - SAFE_BOTTOM;
    } else {
      y = SAFE_TOP;
      maxH = H - SAFE_TOP - SAFE_BOTTOM;
    }
    return { x: x, y: y, maxW: maxW, maxH: maxH };
  }

  // ── Word-wrap text to fit within maxWidth ─────────────────
  function wrapTextLines(ctx, inputLines, maxWidth){
    var result = [];
    for(var li=0; li<inputLines.length; li++){
      var line = inputLines[li];
      var measured = ctx.measureText(line);
      if(measured.width <= maxWidth){
        result.push(line);
      } else {
        // Word-wrap: keep number+unit together (e.g. "15 min", "2 hours", "90 min")
        var words = line.split(/\s+/);
        var currentLine = '';
        for(var wi=0; wi<words.length; wi++){
          var word = words[wi];
          // Keep number+unit pairs together
          if(wi < words.length-1 && /^\d+$/.test(word) && /^(min|AM|PM|hours?|days?|sec|seconds?|minutes?)/.test(words[wi+1])){
            word = word + ' ' + words[wi+1];
            wi++;
          }
          var testLine = currentLine ? currentLine + ' ' + word : word;
          if(ctx.measureText(testLine).width <= maxWidth){
            currentLine = testLine;
          } else {
            if(currentLine) result.push(currentLine);
            currentLine = word;
          }
        }
        if(currentLine) result.push(currentLine);
      }
    }
    return result;
  }

  // ── Measure and layout text with auto-fit ─────────────────
  function measureAndLayout(ctx, lines, slideIndex, maxWidth){
    var role = getSlideRole(slideIndex);
    var steps = FONT_STEPS[role];
    var linesFiltered = lines.filter(function(l){ return l && l.length > 0; });

    for(var si=0; si<steps.length; si++){
      var fs = steps[si];
      ctx.font = "800 " + fs + "px 'Inter','Helvetica Neue',Arial,sans-serif";
      var textMaxW = maxWidth - BAND_PAD_X * 2;

      // Try wrapping at this font size
      var wrapped = wrapTextLines(ctx, linesFiltered, textMaxW);

      if(wrapped.length <= MAX_TEXT_LINES){
        // Balance 2-line text for even width
        var ctxRef = ctx;
        var balanced = balanceWrapLines(wrapped, fs, textMaxW, function(text, _fs){
          return ctxRef.measureText(text).width;
        });
        // Find max line width for band sizing
        var maxLineWidth = 0;
        for(var i=0; i<balanced.length; i++){
          var w = ctx.measureText(balanced[i]).width;
          if(w > maxLineWidth) maxLineWidth = w;
        }
        return {
          lines: balanced,
          fontSize: fs,
          lineHeight: Math.round(fs * 1.35),
          maxLineWidth: maxLineWidth
        };
      }
    }

    // Fallback: use smallest font, accept result
    var smallestFs = steps[steps.length - 1];
    ctx.font = "800 " + smallestFs + "px 'Inter','Helvetica Neue',Arial,sans-serif";
    var textMaxW2 = maxWidth - BAND_PAD_X * 2;
    var fallbackWrapped = wrapTextLines(ctx, linesFiltered, textMaxW2);
    var fallbackMaxW = 0;
    for(var fi=0; fi<fallbackWrapped.length; fi++){
      var fw = ctx.measureText(fallbackWrapped[fi]).width;
      if(fw > fallbackMaxW) fallbackMaxW = fw;
    }
    return {
      lines: fallbackWrapped,
      fontSize: smallestFs,
      lineHeight: Math.round(smallestFs * 1.35),
      maxLineWidth: fallbackMaxW
    };
  }

  // ── Canvas: draw text overlay (auto-sizing band) ────────────
  function drawTextOverlay(ctx, lines, layout, position, brand, slideIndex, variantMode){
    var safe = getSafeArea(position);

    // Measure and layout text with auto-fit
    var measured = measureAndLayout(ctx, lines, slideIndex, safe.maxW);
    var fontSize = measured.fontSize;
    var lineHeight = measured.lineHeight;
    var wrappedLines = measured.lines;
    var maxLineWidth = measured.maxLineWidth;

    // Calculate band dimensions (template-driven)
    var bandTpl = selectBandTemplate(wrappedLines);
    var templateW = Math.round(safe.maxW * BAND_TEMPLATES[bandTpl].widthRatio);
    var contentW = maxLineWidth + BAND_PAD_X * 2;
    var boxW = Math.max(BAND_MIN_W, Math.min(Math.max(templateW, contentW), safe.maxW));
    var textBlockH = wrappedLines.length * lineHeight;
    var boxH = textBlockH + BAND_PAD_Y * 2 + Math.round(fontSize * 0.15); // extra for descenders
    var boxR = BAND_RADIUS;

    // Position the band within safe area
    var boxX, boxY;
    if(position.indexOf("left")!==-1){
      boxX = SAFE_LEFT;
    } else if(position.indexOf("right")!==-1){
      boxX = W - SAFE_RIGHT - boxW;
    } else {
      boxX = Math.round((W - boxW) / 2);
    }
    if(position.indexOf("top")===0){
      boxY = TOP_POSITION_Y;
    } else {
      boxY = H - SAFE_BOTTOM - boxH - 20;
    }

    // Text alignment within band
    var textAlign = "center";
    var textX = boxX + boxW / 2;
    if(position.indexOf("left")!==-1){ textAlign = "left"; textX = boxX + BAND_PAD_X; }
    else if(position.indexOf("right")!==-1){ textAlign = "right"; textX = boxX + boxW - BAND_PAD_X; }

    // Draw band background
    ctx.save();
    if(layout==="poster_dark"){
      ctx.fillStyle = "rgba(35,35,35,0.68)";
      ctx.shadowColor = "rgba(0,0,0,0.16)";
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 8;
      ctx.shadowBlur = 24;
    } else if(layout==="caption_light"){
      ctx.fillStyle = "rgba(255,255,255,0.55)";
      ctx.shadowColor = "rgba(0,0,0,0.08)";
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 4;
      ctx.shadowBlur = 16;
    } else {
      ctx.fillStyle = "rgba(255,255,255,0.18)";
    }
    roundRect(ctx, boxX, boxY, boxW, boxH, boxR);
    ctx.fill();
    ctx.restore();

    // Draw text
    ctx.save();
    ctx.font = "800 " + fontSize + "px 'Inter','Helvetica Neue',Arial,sans-serif";
    ctx.textAlign = textAlign;
    ctx.textBaseline = "alphabetic";

    if(layout==="caption_light"){
      ctx.fillStyle = "#111111";
    } else {
      ctx.fillStyle = "#ffffff";
    }

    if(layout==="caption_subtle"){
      ctx.shadowColor = "rgba(0,0,0,0.55)";
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 3;
      ctx.shadowBlur = 16;
    }

    var textY = boxY + BAND_PAD_Y + fontSize;
    for(var i=0; i<wrappedLines.length; i++){
      ctx.fillText(wrappedLines[i], textX, textY + i * lineHeight);
    }
    ctx.restore();

    // Brand footer
    if(brand){
      ctx.save();
      ctx.font = "500 26px 'Inter','Helvetica Neue',Arial,sans-serif";
      ctx.textAlign = "end";
      ctx.fillStyle = "rgba(255,255,255,0.35)";
      ctx.shadowColor = "rgba(0,0,0,0.55)";
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 3;
      ctx.shadowBlur = 16;
      ctx.fillText("SimpleMemo", W - SAFE_RIGHT, H - SAFE_BOTTOM + 40);
      ctx.restore();
    }
  }

  function roundRect(ctx, x, y, w, h, r){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.lineTo(x+w-r, y);
    ctx.quadraticCurveTo(x+w, y, x+w, y+r);
    ctx.lineTo(x+w, y+h-r);
    ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
    ctx.lineTo(x+r, y+h);
    ctx.quadraticCurveTo(x, y+h, x, y+h-r);
    ctx.lineTo(x, y+r);
    ctx.quadraticCurveTo(x, y, x+r, y);
    ctx.closePath();
  }

  // ── Check slide warnings (overflow, safe area, rules) ─────────
  function checkSlideWarnings(ctx, slides, positions, layouts, lib){
    var warnings = []; // [{slide, badges:[{label,level}]}]
    for(var i = 0; i < slides.length; i++){
      var badges = [];
      var lines = slides[i].filter(function(l){ return l && l.length > 0; });
      var text = lines.join(' ');
      var chars = text.length;
      var words = text.split(/\s+/).filter(function(w){ return w.length > 0; }).length;
      var lineCount = lines.length;

      // Get safe area and measure
      var safe = getSafeArea(positions[i]);
      var measured = measureAndLayout(ctx, slides[i], i, safe.maxW);
      var bandTpl = selectBandTemplate(measured.lines);
      var templateW = Math.round(safe.maxW * BAND_TEMPLATES[bandTpl].widthRatio);
      var contentW = measured.maxLineWidth + BAND_PAD_X * 2;
      var boxW = Math.max(BAND_MIN_W, Math.min(Math.max(templateW, contentW), safe.maxW));

      // Overflow: content wider than safe area
      if(contentW > safe.maxW){
        badges.push({ label: 'Overflow', level: 'err' });
      }

      // Safe area: top band too close to edge
      var textBlockH = measured.lines.length * measured.lineHeight;
      var boxH = textBlockH + BAND_PAD_Y * 2 + Math.round(measured.fontSize * 0.15);
      if(positions[i].indexOf('top') === 0){
        var boxY = TOP_POSITION_Y;
        if(boxY < SAFE_TOP){
          badges.push({ label: 'Safe area', level: 'warn' });
        }
      }

      // Slide rules check
      if(lib && lib.slideRules){
        var rule = lib.slideRules['slide' + (i + 1)];
        if(rule){
          if(rule.maxChars && chars > rule.maxChars) badges.push({ label: 'Chars:'+chars+'/'+rule.maxChars, level: 'warn' });
          if(rule.maxWords && words > rule.maxWords) badges.push({ label: 'Words:'+words+'/'+rule.maxWords, level: 'warn' });
          if(rule.maxLines && lineCount > rule.maxLines) badges.push({ label: 'Lines:'+lineCount+'/'+rule.maxLines, level: 'warn' });
        }
      }

      // Slide 1 hook check: is it a question/rule instead of a hook?
      if(i === 0){
        var hookText = text.toLowerCase();
        if(hookText.indexOf('the fix:') === 0 || hookText.indexOf('rule') === 0 || hookText.indexOf('step') === 0){
          badges.push({ label: 'Hook?', level: 'warn' });
        }
      }

      warnings.push({ slide: i, badges: badges });
    }
    return warnings;
  }

  // ── Compose single slide on canvas ───────────────────────────
  function composeSlide(bgImg, lines, layout, position, cropVariant, brand, slideIndex, variantMode){
    var canvas = document.createElement('canvas');
    canvas.width = W;
    canvas.height = H;
    var ctx = canvas.getContext('2d');

    var crop = getCropRegion(bgImg.naturalWidth, bgImg.naturalHeight, cropVariant);
    ctx.drawImage(bgImg, crop.left, crop.top, crop.width, crop.height, 0, 0, W, H);

    drawTextOverlay(ctx, lines, layout, position, brand, slideIndex, variantMode);

    return canvas;
  }

  // ── Canvas to Blob ────────────────────────────────────────────
  function canvasToBlob(canvas){
    return new Promise(function(resolve){
      canvas.toBlob(function(blob){ resolve(blob); }, 'image/png');
    });
  }

  // ── Init 6 empty slots ──────────────────────────────────────
  function initSlots(){
    gridEl.innerHTML = '';
    for(var i=0;i<6;i++){
      var s = document.createElement('div');
      s.className = 'slot'; s.id = 'slot-'+i;
      s.innerHTML = '<span class="slot-n">'+(i+1)+'</span>'
        +'<div class="slot-img" id="img-'+i+'">—</div>'
        +'<div class="warn-badges" id="warn-'+i+'"></div>'
        +'<div class="slot-meta"><span id="meta-'+i+'"></span><button class="btn-sm btn-outline" data-i="'+i+'" style="display:none">Regen</button></div>';
      gridEl.appendChild(s);
    }
    gridEl.querySelectorAll('[data-i]').forEach(function(btn){
      btn.addEventListener('click', function(){ regenSlide(parseInt(btn.dataset.i)); });
    });
  }
  initSlots();

  function showSlide(i, url, meta){
    var wrap = $('img-'+i);
    wrap.innerHTML = '<img src="'+url+'">';
    var metaEl = $('meta-'+i);
    metaEl.textContent = meta || '';
    var btn = gridEl.querySelector('[data-i="'+i+'"]');
    if(btn) btn.style.display = '';
  }

  // ── UI: show/hide mode-specific controls ─────────────────────
  $('pattern-mode').addEventListener('change', function(){
    var mode = this.value;
    $('tag-select-wrap').style.display = mode === 'tag' ? '' : 'none';
    $('seed-wrap').style.display = mode === 'seeded' ? '' : 'none';
  });

  // ── Variant change: reload categories ─────────────────────────
  $('variant').addEventListener('change', async function(){
    var variant = this.value;
    var lib = await loadPatterns(variant);
    if(lib) populateCategories(lib);
  });

  // ── Diversity threshold mapping ───────────────────────────────
  function getDiversityThreshold(){
    var val = $('diversity').value;
    if(val === 'low') return 0.2;
    if(val === 'high') return 0.6;
    return 0.4;
  }

  // ── Generate 6 slides ────────────────────────────────────────
  $('gen-btn').addEventListener('click', async function(){
    var btn = $('gen-btn');
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner"></span>Generating...';
    $('status').textContent = '';
    $('dl-row').style.display = 'none';
    $('pattern-badge').innerHTML = '';
    initSlots();
    currentBlobs = [];
    currentPattern = null;
    currentSlides = null;
    abBlobsB = [];
    abTextsB = null;

    var variant = $('variant').value;
    var brandChecked = $('brand').checked;
    var hookSwapEnabled = $('hook-swap').checked;
    var abMode = $('ab-mode').checked;
    var mode = $('pattern-mode').value;
    var tagFilter = $('tag-select').value;
    var seedId = $('seed-input').value.trim();
    var avoidN = parseInt($('avoid-recent').value) || 20;
    var divThreshold = getDiversityThreshold();
    var t0 = Date.now();

    log('i', 'Generating variant='+variant+' mode='+mode+' hookSwap='+(hookSwapEnabled?'ON':'OFF')+' brand='+(brandChecked?'ON':'OFF'));
    log('i', 'Loading background images...');

    // Load pattern library
    var lib = await loadPatterns(variant);
    var texts;
    var selectedPattern = null;
    var safetyResult = null;
    var similarity = 0;
    var brandSlideOnly = -1; // -1 = use brandChecked for all, >= 0 = only that slide
    var bgTypes = null;

    if(lib){
      // Get library config
      if(lib.brandSlideOnly !== undefined) brandSlideOnly = lib.brandSlideOnly;
      bgTypes = lib.defaultBgTypes || null;

      // Use pattern library
      var selection = selectPattern(lib, mode, tagFilter, seedId, avoidN, divThreshold);
      selectedPattern = selection.pattern;
      similarity = selection.similarity || 0;
      currentPattern = selectedPattern;

      // Per-pattern bgTypes override
      if(selectedPattern.bgTypes) bgTypes = selectedPattern.bgTypes;

      // Safety check
      safetyResult = checkSafety(selectedPattern, lib);
      if(!safetyResult.passed){
        log('w', 'Safety filter triggered for '+selectedPattern.id+': '+safetyResult.bannedHits.join(', '));
        // Try to find a safe alternative
        for(var retry=0; retry<5; retry++){
          selection = selectPattern(lib, 'random', '', '', avoidN, divThreshold);
          selectedPattern = selection.pattern;
          similarity = selection.similarity || 0;
          currentPattern = selectedPattern;
          safetyResult = checkSafety(selectedPattern, lib);
          if(safetyResult.passed) break;
        }
      }

      texts = selectedPattern.slides.map(function(s){ return s.slice(); }); // deep copy
      addToHistory(selectedPattern.id);

      log('i', 'Pattern: '+selectedPattern.id+' ['+selectedPattern.category+'] sim='+similarity.toFixed(3)+' attempts='+selection.attempts);
      if(safetyResult.cautionHits.length > 0){
        log('w', 'Caution words: '+safetyResult.cautionHits.join(', '));
      }

      // Hook swap
      if(hookSwapEnabled){
        var hookResult = swapHook(texts, variant);
        if(hookResult.hookId){
          texts = hookResult.slides;
          log('i', 'Hook swapped → '+hookResult.hookId+' ('+hookResult.hookTone+'/'+hookResult.hookCategory+'): "'+texts[0].join(' ')+'"');
        }
      }

      // NG filter
      var ngIssues = ngFilter(texts);
      if(ngIssues.length > 0){
        for(var ni=0; ni<ngIssues.length; ni++){
          var issue = ngIssues[ni];
          if(issue.type === 'word_repeat'){
            log('w', 'NG: "'+issue.word+'" repeated in '+issue.count+' slides');
          } else if(issue.type === 'long_hook'){
            log('w', 'NG: Hook has '+issue.words+' words (max 12)');
          }
        }
      }

      currentSlides = texts;

      // Slide rules validation
      if(lib && lib.slideRules){
        var ruleWarnings = validateSlideRules(texts, lib.slideRules);
        for(var ri = 0; ri < ruleWarnings.length; ri++){
          var rw = ruleWarnings[ri];
          log('w', 'SlideRule: slide '+rw.slide+' '+rw.type+'='+rw.value+' exceeds max='+rw.max);
        }
      }

      // Show pattern badge
      var badgeCls = safetyResult.passed ? 'badge-ok' : 'badge-err';
      $('pattern-badge').innerHTML = '<span class="badge '+badgeCls+'">'+selectedPattern.id+'</span>'
        + '<span class="badge badge-ok">'+selectedPattern.category+'</span>'
        + '<span class="badge badge-ok">sim: '+similarity.toFixed(2)+'</span>';
    } else {
      // Fallback to hardcoded scripts
      texts = FALLBACK_SCRIPTS[variant] || FALLBACK_SCRIPTS.B;
      currentSlides = texts;
      log('w', 'Using fallback scripts (no pattern library)');
    }

    preloadBackgrounds(bgTypes, function(){
      log('ok', '6 backgrounds loaded');

      // Layout consistency: use fixed values from lib config if available
      var layouts = (lib && lib.fixedLayout)
        ? [lib.fixedLayout,lib.fixedLayout,lib.fixedLayout,lib.fixedLayout,lib.fixedLayout,lib.fixedLayout]
        : assignLayouts();
      var positions = (lib && lib.fixedPosition)
        ? [lib.fixedPosition,lib.fixedPosition,lib.fixedPosition,lib.fixedPosition,lib.fixedPosition,lib.fixedPosition]
        : assignPositions();
      var crops = assignCrops();

      // Calculate text lengths per slide
      var textLengths = texts.map(function(s){
        return s.filter(function(l){return l;}).join(' ').length;
      });

      var plan = {
        generated_at: new Date().toISOString(),
        variant: variant,
        brand: brandChecked,
        brandSlideOnly: brandSlideOnly,
        output_size: W+'x'+H,
        pattern_id: selectedPattern ? selectedPattern.id : 'fallback',
        pattern_category: selectedPattern ? selectedPattern.category : null,
        pattern_tags: selectedPattern ? selectedPattern.tags : [],
        pattern_structure: selectedPattern ? selectedPattern.structure : null,
        similarity_score: similarity,
        safety_filter_result: safetyResult ? {
          passed: safetyResult.passed,
          banned_hits: safetyResult.bannedHits,
          caution_hits: safetyResult.cautionHits,
          app_name_count: safetyResult.appNameCount
        } : null,
        text_length_per_slide: textLengths,
        diversity_setting: $('diversity').value,
        avoid_recent_n: avoidN,
        pattern_mode: mode,
        hook_swap: hookSwapEnabled,
        slides: []
      };

      var generated = 0;

      function processSlide(i){
        // Brand logic: if brandSlideOnly >= 0, only show on that slide; otherwise use checkbox
        var showBrand;
        if(brandSlideOnly >= 0){
          showBrand = brandChecked && (i === brandSlideOnly);
        } else {
          showBrand = brandChecked;
        }

        var canvas = composeSlide(bgImages[i], texts[i], layouts[i], positions[i], crops[i], showBrand, i, variant);

        plan.slides.push({
          slide_index: i,
          background: (i+1)+'.jpg',
          text: texts[i],
          text_length: textLengths[i],
          layout_variant: layouts[i],
          text_position: positions[i],
          crop_variant: crops[i],
          brand: showBrand
        });

        canvasToBlob(canvas).then(function(blob){
          currentBlobs[i] = blob;
          var sizeKB = Math.round(blob.size/1024);
          var url = URL.createObjectURL(blob);
          var meta = layouts[i]+' \u00b7 '+crops[i]+' \u00b7 '+sizeKB+'KB';
          showSlide(i, url, meta);
          log('ok', 'Slide '+(i+1)+': '+layouts[i]+' / '+positions[i]+' / '+crops[i]+(showBrand?' +brand':''));

          generated++;
          if(generated===6){
            currentPlan = plan;
            var sec = ((Date.now()-t0)/1000).toFixed(1);
            $('status').textContent = '6枚生成完了 ('+sec+'s)' + (selectedPattern ? ' — Pattern '+selectedPattern.id : '');
            $('timer').textContent = sec+'s';
            $('dl-row').style.display = 'flex';
            log('ok', 'Done in '+sec+'s — Pattern: '+(selectedPattern ? selectedPattern.id+' ['+selectedPattern.category+']' : 'fallback'));
            btn.disabled = false;
            btn.textContent = 'Generate 6 Slides';

            // Show warning badges
            showWarningBadges(texts, positions, layouts, lib);

            // A/B mode: generate variant B with different hook
            if(abMode && hooksLibrary){
              log('i', 'A/B mode: generating variant B...');
              var textsB = texts.map(function(s){ return s.slice(); });
              var hookB = swapHook(textsB, variant);
              if(hookB.hookId){
                textsB = hookB.slides;
                abTextsB = textsB;
                log('i', 'Variant B hook: '+hookB.hookId+' ('+hookB.hookTone+'/'+hookB.hookCategory+'): "'+textsB[0].join(' ')+'"');
                var bGenerated = 0;
                for(var bi=0; bi<6; bi++){
                  (function(idx){
                    var showBrandB;
                    if(brandSlideOnly >= 0){
                      showBrandB = brandChecked && (idx === brandSlideOnly);
                    } else {
                      showBrandB = brandChecked;
                    }
                    var canvasB = composeSlide(bgImages[idx], textsB[idx], layouts[idx], positions[idx], crops[idx], showBrandB, idx, variant);
                    canvasToBlob(canvasB).then(function(blob){
                      abBlobsB[idx] = blob;
                      bGenerated++;
                      if(bGenerated === 6){
                        log('ok', 'A/B variant B generated (6 slides)');
                      }
                    });
                  })(bi);
                }
              }
            }
          }
        });
      }

      for(var i=0;i<6;i++){
        processSlide(i);
      }
    });
  });

  // ── Regenerate single slide ──────────────────────────────────
  function regenSlide(index){
    if(!currentPlan || !bgImages[index]) return;
    var btn = gridEl.querySelector('[data-i="'+index+'"]');
    btn.textContent = '...';

    var variant = $('variant').value;
    var brandChecked = $('brand').checked;
    var brandSlideOnly = currentPlan.brandSlideOnly;
    var texts = currentSlides || (currentPattern ? currentPattern.slides : (FALLBACK_SCRIPTS[variant] || FALLBACK_SCRIPTS.B));
    log('i', 'Regenerating slide '+(index+1)+'...');

    var layout = LAYOUTS[Math.floor(Math.random()*LAYOUTS.length)];
    var position = POSITIONS[Math.floor(Math.random()*POSITIONS.length)];
    var crop = CROPS[Math.floor(Math.random()*CROPS.length)];

    var showBrand;
    if(brandSlideOnly >= 0){
      showBrand = brandChecked && (index === brandSlideOnly);
    } else {
      showBrand = brandChecked;
    }

    var canvas = composeSlide(bgImages[index], texts[index], layout, position, crop, showBrand, index, variant);

    canvasToBlob(canvas).then(function(blob){
      currentBlobs[index] = blob;

      currentPlan.slides[index] = {
        slide_index: index,
        background: (index+1)+'.jpg',
        text: texts[index],
        text_length: texts[index].filter(function(l){return l;}).join(' ').length,
        layout_variant: layout,
        text_position: position,
        crop_variant: crop,
        brand: showBrand
      };

      var sizeKB = Math.round(blob.size/1024);
      var url = URL.createObjectURL(blob);
      showSlide(index, url, layout+' \u00b7 '+crop+' \u00b7 '+sizeKB+'KB');
      btn.textContent = 'Regen';
      log('ok', 'Slide '+(index+1)+' regenerated: '+layout+' / '+position+' / '+crop);
    });
  }

  // ── Show warning badges on slides ──────────────────────────────
  function showWarningBadges(texts, positions, layouts, lib){
    // Create a temp canvas for measurement
    var tmpCanvas = document.createElement('canvas');
    tmpCanvas.width = W; tmpCanvas.height = H;
    var tmpCtx = tmpCanvas.getContext('2d');
    tmpCtx.font = "800 64px 'Inter','Helvetica Neue',Arial,sans-serif";

    var warnings = checkSlideWarnings(tmpCtx, texts, positions, layouts, lib);
    var totalWarnings = 0;
    for(var i = 0; i < warnings.length; i++){
      var warnEl = $('warn-'+i);
      if(!warnEl) continue;
      warnEl.innerHTML = '';
      var badges = warnings[i].badges;
      totalWarnings += badges.length;
      for(var j = 0; j < badges.length; j++){
        var span = document.createElement('span');
        span.className = 'warn-badge warn-badge-' + badges[j].level;
        span.textContent = badges[j].label;
        warnEl.appendChild(span);
      }
    }
    if(totalWarnings > 0){
      log('w', totalWarnings + ' warning(s) detected across slides');
    }
  }

  // ── A/B mode state ─────────────────────────────────────────────
  var abBlobsB = []; // variant B blobs for A/B mode
  var abTextsB = null; // variant B texts

  // ── ZIP download ──────────────────────────────────────────────
  $('zip-btn').addEventListener('click', function(){
    if(!currentPlan || currentBlobs.length<6) return;
    var zipBtn = $('zip-btn');
    zipBtn.textContent = 'Packing...';
    zipBtn.disabled = true;
    log('i', 'Creating ZIP...');

    var zip = new JSZip();
    var isAB = abBlobsB.length === 6;

    if(isAB){
      // A/B mode: variant_A and variant_B folders
      for(var i=0;i<6;i++){
        if(currentBlobs[i]) zip.file('variant_A/slide_'+(i+1)+'.png', currentBlobs[i]);
        if(abBlobsB[i]) zip.file('variant_B/slide_'+(i+1)+'.png', abBlobsB[i]);
      }
      var abSummary = {
        variant_A: { texts: currentSlides },
        variant_B: { texts: abTextsB },
        generated_at: new Date().toISOString()
      };
      zip.file('ab_summary.json', JSON.stringify(abSummary, null, 2));
    } else {
      for(var i=0;i<6;i++){
        if(currentBlobs[i]) zip.file('slide_'+(i+1)+'.png', currentBlobs[i]);
      }
    }

    zip.file('slide_plan.json', JSON.stringify(currentPlan, null, 2));

    zip.generateAsync({type:'blob'}).then(function(content){
      var a = document.createElement('a');
      a.href = URL.createObjectURL(content);
      var ts = new Date().toISOString().replace(/[:.]/g,'-').slice(0,19);
      a.download = 'slides_'+currentPlan.variant+'_'+(currentPlan.pattern_id||'fb')+'_'+(isAB?'AB_':'')+ts+'.zip';
      a.click();
      zipBtn.textContent = 'ZIP Download';
      zipBtn.disabled = false;
      log('ok', 'ZIP downloaded: '+a.download);
    });
  });

  // ── Post to TikTok via Postiz ───────────────────────────────
  $('tiktok-btn').addEventListener('click', async function(){
    if(!currentPlan || currentBlobs.length<6){
      log('err', 'スライドを先に生成してください'); return;
    }
    var btn = $('tiktok-btn');
    btn.disabled = true;
    btn.textContent = '送信中...';
    log('i', 'TikTok投稿を開始…');

    try {
      var uploaded = [];
      for(var i=0;i<6;i++){
        var blob = currentBlobs[i];
        var form = new FormData();
        form.append('file', blob, 'slide_'+(i+1)+'.png');

        log('i', 'slide_'+(i+1)+'.png アップロード中…');
        var res = await fetch('/admin/api/upload', { method: 'POST', body: form });
        var data = await res.json();
        if(!res.ok) throw new Error('Upload failed: slide_'+(i+1)+' ('+res.status+') '+(data.error||JSON.stringify(data)));
        uploaded.push({ id: data.id, path: data.path });
        log('ok', 'slide_'+(i+1)+'.png → '+data.path);
      }

      var hook = currentPlan.slides[0].text.filter(function(t){return t;}).join(' ');
      var caption = hook + '\n\nSimple Memo - one tap, straight to your inbox.\n\n#simplememo #productivity #notetaking #lifehack #iphone';

      log('i', '投稿作成中（1分後に予約）…');
      var postRes = await fetch('/admin/api/post-tiktok', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ images: uploaded, caption: caption })
      });
      var postData = await postRes.json();
      if(!postRes.ok) throw new Error('Post failed: '+JSON.stringify(postData));

      log('ok', 'TikTok投稿を予約しました！ ('+postData.scheduleDate+')');
      log('ok', '約1分後にTikTokへ送信 → システム通知が届きます');
      btn.textContent = '送信完了!';
      setTimeout(function(){ btn.textContent = 'TikTokへ送る'; btn.disabled = false; }, 3000);
    } catch(e) {
      log('err', 'エラー: '+e.message);
      btn.textContent = 'TikTokへ送る';
      btn.disabled = false;
    }
  });

  // ── Export log (enhanced) ─────────────────────────────────────
  $('log-btn').addEventListener('click', function(){
    if(!currentPlan) return;
    var json = JSON.stringify(currentPlan, null, 2);
    var blob = new Blob([json], {type:'application/json'});
    var a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'slide_plan_'+(currentPlan.pattern_id||'fb')+'_'+new Date().toISOString().replace(/[:.]/g,'-').slice(0,19)+'.json';
    a.click();
    log('i', 'Exported '+a.download);
  });

  // ── Init ─────────────────────────────────────────────────────
  log('i', 'Ready. Select variant and click Generate.');
  log('i', 'Loading pattern libraries...');
  loadPatterns('W');
  loadHooks();
})();
</script>

</body>
</html>
