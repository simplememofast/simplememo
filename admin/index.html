<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="noindex, nofollow">
  <title>TikTok Slide Builder v2</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@500;800&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    :root {
      --bg: #000; --surface: #0d1117; --accent: #6ab4ff; --accent2: #4fc3f7;
      --green: #3fb950; --red: #f85149; --yellow: #d29922;
      --text: #fff; --text2: rgba(255,255,255,.7); --text3: rgba(255,255,255,.45);
      --border: rgba(100,160,220,.12); --border2: rgba(100,180,255,.25);
      --r: 10px; --font: 'Inter',-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;
    }
    *{box-sizing:border-box;margin:0;padding:0}
    body{font-family:var(--font);background:var(--bg);color:var(--text);min-height:100dvh}

    .hdr{padding:12px 20px;border-bottom:1px solid var(--border);display:flex;align-items:center;justify-content:space-between;position:sticky;top:0;background:rgba(0,0,0,.92);backdrop-filter:blur(12px);z-index:50}
    .hdr h1{font-size:.88rem;font-weight:600;color:var(--text2)} .hdr h1 b{color:var(--accent)}

    .main{padding:20px;max-width:1100px;margin:0 auto}

    .card{background:var(--surface);border:1px solid var(--border);border-radius:var(--r);margin-bottom:16px;overflow:hidden}
    .card-h{padding:10px 14px;border-bottom:1px solid var(--border);font-size:.8rem;font-weight:600;color:var(--text2);display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap}

    .card-b{padding:14px}

    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}

    select,button,input[type=number]{font-family:var(--font);font-size:.8rem;border-radius:6px;border:1px solid var(--border);background:var(--bg);color:var(--text);padding:7px 12px;cursor:pointer}
    input[type=number]{width:60px;cursor:text}
    select:focus,button:focus,input:focus{outline:none;border-color:var(--accent)}
    .btn-accent{background:var(--accent);color:#000;font-weight:700;border:none;padding:8px 22px}
    .btn-accent:hover{background:var(--accent2)}
    .btn-accent:disabled{opacity:.5;cursor:wait}
    .btn-sm{padding:4px 10px;font-size:.72rem}
    .btn-outline{background:transparent;color:var(--text2)}
    .btn-outline:hover{border-color:var(--border2);color:var(--text)}
    .btn-green{background:var(--green);color:#000;border:none}
    .btn-dl{background:rgba(63,185,80,.12);color:var(--green);border:1px solid rgba(63,185,80,.3)}

    label{font-size:.78rem;color:var(--text3)}
    .check-row{display:flex;align-items:center;gap:6px}
    .check-row input[type=checkbox]{accent-color:var(--accent)}

    .grid{display:grid;grid-template-columns:repeat(6,1fr);gap:8px}
    @media(max-width:900px){.grid{grid-template-columns:repeat(3,1fr)}}
    @media(max-width:500px){.grid{grid-template-columns:repeat(2,1fr)}}

    .slot{background:var(--bg);border:1px solid var(--border);border-radius:8px;overflow:hidden;position:relative}
    .slot:hover{border-color:var(--border2)}
    .slot-n{position:absolute;top:4px;left:4px;background:rgba(0,0,0,.7);color:var(--text3);font-size:.6rem;font-weight:700;padding:1px 6px;border-radius:3px;z-index:2}
    .slot-type{position:absolute;top:4px;right:4px;background:rgba(0,0,0,.7);font-size:.55rem;font-weight:600;padding:1px 5px;border-radius:3px;z-index:2}
    .slot-type.t-desk{color:#4fc3f7} .slot-type.t-hand{color:#ff9800} .slot-type.t-proof{color:#3fb950}
    .slot-img{width:100%;aspect-ratio:9/16;display:flex;align-items:center;justify-content:center;color:var(--text3);font-size:.7rem;overflow:hidden}
    .slot-img img{width:100%;height:100%;object-fit:cover}
    .slot-meta{padding:6px 8px;border-top:1px solid var(--border);font-size:.6rem;color:var(--text3);display:flex;justify-content:space-between;align-items:center}

    .log{background:var(--bg);border:1px solid var(--border);border-radius:6px;padding:10px;font-family:'SF Mono','Fira Code',monospace;font-size:.68rem;color:var(--text3);max-height:200px;overflow-y:auto;white-space:pre-wrap;word-break:break-all;line-height:1.6}
    .log .ok{color:var(--green)} .log .err{color:var(--red)} .log .i{color:var(--accent)} .log .w{color:var(--yellow)}

    .spinner{display:inline-block;width:14px;height:14px;border:2px solid var(--text3);border-top-color:var(--accent);border-radius:50%;animation:spin .6s linear infinite;vertical-align:middle;margin-right:6px}
    @keyframes spin{to{transform:rotate(360deg)}}

    .status{font-size:.75rem;color:var(--text3);margin-top:8px}
    .badge{display:inline-block;padding:1px 7px;border-radius:4px;font-size:.65rem;font-weight:600;margin-left:6px}
    .badge-ok{background:rgba(63,185,80,.15);color:var(--green)}
    .badge-warn{background:rgba(210,153,34,.15);color:var(--yellow)}
    .badge-err{background:rgba(248,81,73,.15);color:var(--red)}
    .badge-blue{background:rgba(106,180,255,.15);color:var(--accent)}
  </style>
</head>
<body>

<header class="hdr">
  <h1><b>TikTok</b> Slide Builder <span style="font-size:.65rem;color:var(--text3)">v2</span></h1>
  <span id="timer" style="font-size:.75rem;color:var(--text3)"></span>
</header>

<div class="main">

  <!-- Controls -->
  <div class="card">
    <div class="card-h">Generate</div>
    <div class="card-b">
      <div class="row">
        <div>
          <label>Variant</label><br>
          <select id="variant">
            <option value="A" selected>A — 忘れる系 (103 patterns)</option>
            <option value="B">B — 時短・実利系 (15 patterns)</option>
            <option value="C">C — 対立煽り系 (15 patterns)</option>
          </select>
        </div>
        <div>
          <label>Pattern Mode</label><br>
          <select id="pattern-mode">
            <option value="random" selected>Random</option>
            <option value="tag">Tag-based</option>
            <option value="seeded">Seeded</option>
          </select>
        </div>
        <div id="tag-select-wrap" style="display:none">
          <label>Category</label><br>
          <select id="tag-select"></select>
        </div>
        <div id="seed-wrap" style="display:none">
          <label>Pattern ID</label><br>
          <input type="text" id="seed-input" placeholder="A001" style="width:80px;font-family:var(--font);font-size:.8rem;border-radius:6px;border:1px solid var(--border);background:var(--bg);color:var(--text);padding:7px 12px">
        </div>
        <div>
          <label>Diversity</label><br>
          <select id="diversity">
            <option value="low">Low (0.2)</option>
            <option value="mid" selected>Mid (0.4)</option>
            <option value="high">High (0.6)</option>
          </select>
        </div>
        <div>
          <label>Avoid Recent</label><br>
          <input type="number" id="avoid-recent" value="20" min="0" max="99">
        </div>
        <div class="check-row" style="margin-top:14px">
          <input type="checkbox" id="hook-swap"><label for="hook-swap">Hook Swap</label>
        </div>
        <div class="check-row" style="margin-top:14px">
          <input type="checkbox" id="brand"><label for="brand">Brand Footer</label>
        </div>
        <button class="btn-accent" id="gen-btn" style="margin-top:14px">Generate 6 Slides</button>
      </div>
    </div>
  </div>

  <!-- Preview -->
  <div class="card">
    <div class="card-h">
      <span>Slides Preview <span id="pattern-badge"></span></span>
      <div class="row" id="dl-row" style="display:none">
        <button class="btn-sm btn-dl" id="zip-btn">ZIP Download</button>
        <button class="btn-sm btn-outline" id="log-btn">Export Log</button>
        <button class="btn-sm btn-green" id="tiktok-btn">TikTokへ送る</button>
      </div>
    </div>
    <div class="card-b">
      <div class="grid" id="grid"></div>
      <div class="status" id="status"></div>
    </div>
  </div>

  <!-- Log -->
  <div class="card">
    <div class="card-h">Log</div>
    <div class="card-b">
      <div class="log" id="log">待機中…</div>
    </div>
  </div>

</div>

<script>
(function(){
  var $ = function(id){ return document.getElementById(id) };
  var logEl = $('log');
  var gridEl = $('grid');
  var currentPlan = null;
  var currentBlobs = [];
  var currentPattern = null;
  var currentTexts = null;

  // ── Pattern & hooks data ────────────────────────────────────────
  var patternLibrary = {};   // { A: { patterns: [...], ... }, B: {...}, C: {...} }
  var hooksLibrary = null;   // { hooks: [...] }

  // ── Logging ────────────────────────────────────────────────────
  function log(cls, msg){
    if(logEl.textContent==='待機中…') logEl.textContent='';
    var d = document.createElement('div');
    d.className = cls;
    d.textContent = '['+new Date().toLocaleTimeString()+'] '+msg;
    logEl.appendChild(d);
    logEl.scrollTop = logEl.scrollHeight;
  }

  // ── Recent history (localStorage) ──────────────────────────────
  var HISTORY_KEY = 'tiktok_pattern_history';
  function getHistory(){
    try { return JSON.parse(localStorage.getItem(HISTORY_KEY)) || []; } catch(e){ return []; }
  }
  function addToHistory(patternId){
    var h = getHistory();
    h.unshift(patternId);
    if(h.length > 200) h = h.slice(0, 200);
    localStorage.setItem(HISTORY_KEY, JSON.stringify(h));
  }

  // ── Hook history (avoid reusing same hook within 10 posts) ─────
  var HOOK_HISTORY_KEY = 'tiktok_hook_history';
  function getHookHistory(){
    try { return JSON.parse(localStorage.getItem(HOOK_HISTORY_KEY)) || []; } catch(e){ return []; }
  }
  function addToHookHistory(hookId){
    var h = getHookHistory();
    h.unshift(hookId);
    if(h.length > 50) h = h.slice(0, 50);
    localStorage.setItem(HOOK_HISTORY_KEY, JSON.stringify(h));
  }

  // ── Load pattern library ────────────────────────────────────────
  async function loadPatterns(variant){
    if(patternLibrary[variant]) return patternLibrary[variant];
    try {
      var res = await fetch('patterns/'+variant+'.json');
      if(!res.ok) return null;
      var data = await res.json();
      patternLibrary[variant] = data;
      log('ok', 'Loaded '+data.patterns.length+' patterns for variant '+variant);
      // Populate category dropdown
      if(data.categories){
        var sel = $('tag-select');
        sel.innerHTML = '<option value="">All</option>';
        data.categories.forEach(function(c){
          var opt = document.createElement('option');
          opt.value = c;
          opt.textContent = c.replace(/_/g,' ').replace(/\b\w/g, function(l){return l.toUpperCase();});
          sel.appendChild(opt);
        });
      }
      return data;
    } catch(e){
      log('w', 'No pattern library for variant '+variant);
      return null;
    }
  }

  // ── Load hooks library ──────────────────────────────────────────
  async function loadHooks(){
    if(hooksLibrary) return hooksLibrary;
    try {
      var res = await fetch('patterns/hooks.json');
      if(!res.ok) return null;
      hooksLibrary = await res.json();
      log('ok', 'Loaded '+hooksLibrary.hooks.length+' hook alternatives');
      return hooksLibrary;
    } catch(e){
      log('w', 'Could not load hooks.json');
      return null;
    }
  }

  // ── Similarity: Jaccard on words ────────────────────────────────
  function tokenize(text){
    return text.toLowerCase().replace(/[^a-z0-9\s]/g,'').split(/\s+/).filter(function(w){ return w.length > 1; });
  }

  function jaccardSimilarity(textA, textB){
    var a = tokenize(textA);
    var b = tokenize(textB);
    if(a.length===0 && b.length===0) return 0;
    var setA = {}; a.forEach(function(w){ setA[w]=1; });
    var setB = {}; b.forEach(function(w){ setB[w]=1; });
    var intersection = 0, union = {};
    for(var k in setA){ union[k]=1; if(setB[k]) intersection++; }
    for(var k in setB){ union[k]=1; }
    var unionSize = Object.keys(union).length;
    return unionSize === 0 ? 0 : intersection / unionSize;
  }

  function patternToText(pattern){
    return pattern.slides.map(function(s){ return s.join(' '); }).join(' ');
  }

  // ── NG Filter: word repetition, abstract-only, explanation-in-hook ─
  var STOP_WORDS = ['i','a','an','the','is','it','to','my','in','of','and','or','but','not','no','do','be','so','that','this','for','you','your','just','don','t','s','re','ll','ve','m','d'];
  var ABSTRACT_WORDS = ['better','more','less','good','great','always','never','every','nothing','everything','something','real','true','simple','easy','hard','best','worst','way','thing','stuff','time'];

  function ngFilter(slides){
    var issues = [];

    // 1. Word repetition: count words across slides, flag if any content word appears in 3+ slides
    var wordSlideCount = {};
    slides.forEach(function(lines, idx){
      var text = lines.join(' ').toLowerCase().replace(/[^a-z0-9\s]/g,'');
      var words = text.split(/\s+/).filter(function(w){ return w.length > 2 && STOP_WORDS.indexOf(w) === -1; });
      var seen = {};
      words.forEach(function(w){
        if(!seen[w]){ seen[w] = true; wordSlideCount[w] = (wordSlideCount[w]||0) + 1; }
      });
    });
    for(var w in wordSlideCount){
      if(wordSlideCount[w] >= 3){
        issues.push({type:'word_repeat', word:w, count:wordSlideCount[w], severity:'warn'});
      }
    }

    // 2. Abstract-only slides: flag if all content words are abstract
    slides.forEach(function(lines, idx){
      if(idx === 0 || idx === 5) return; // skip hook and CTA
      var text = lines.join(' ').toLowerCase().replace(/[^a-z0-9\s]/g,'');
      var words = text.split(/\s+/).filter(function(w){ return w.length > 2 && STOP_WORDS.indexOf(w) === -1; });
      if(words.length === 0) return;
      var abstractCount = words.filter(function(w){ return ABSTRACT_WORDS.indexOf(w) !== -1; }).length;
      if(abstractCount === words.length){
        issues.push({type:'abstract_only', slide:idx+1, severity:'warn'});
      }
    });

    // 3. Explanation in slide 1: flag if hook has more than 12 words
    var hookWords = slides[0].join(' ').split(/\s+/).filter(function(w){return w.length > 0;}).length;
    if(hookWords > 12){
      issues.push({type:'long_hook', words:hookWords, severity:'err'});
    }

    return issues;
  }

  // ── Banned/caution word filter ──────────────────────────────────
  var DEFAULT_BANNED = [
    "free money","guaranteed","100%","cure","miracle","hack your",
    "doctors hate","secret trick","make money","get rich","no effort",
    "limited time","act now","don't miss","once in a lifetime"
  ];
  var DEFAULT_CAUTION = [
    "download","install","buy","subscribe","sign up","ADHD",
    "depression","anxiety","mental health","disorder"
  ];

  function checkSafety(pattern, lib){
    var banned = (lib && lib.bannedWords) || DEFAULT_BANNED;
    var caution = (lib && lib.cautionWords) || DEFAULT_CAUTION;
    var text = patternToText(pattern).toLowerCase();
    var result = { passed: true, bannedHits: [], cautionHits: [], appNameCount: 0 };

    banned.forEach(function(w){
      if(text.indexOf(w.toLowerCase()) !== -1){
        result.bannedHits.push(w);
        result.passed = false;
      }
    });

    caution.forEach(function(w){
      if(text.indexOf(w.toLowerCase()) !== -1){
        result.cautionHits.push(w);
      }
    });

    var appRegex = /simple\s*memo/gi;
    var matches = text.match(appRegex);
    result.appNameCount = matches ? matches.length : 0;
    if(result.appNameCount > 1){
      result.passed = false;
      result.bannedHits.push('App name mentioned '+result.appNameCount+' times (max 1)');
    }

    return result;
  }

  // ── Pattern selection algorithm ─────────────────────────────────
  function selectPattern(lib, mode, tagFilter, seedId, avoidN, diversityThreshold){
    var patterns = lib.patterns;
    var history = getHistory();
    var recentIds = history.slice(0, avoidN);

    if(mode === 'seeded' && seedId){
      var found = patterns.filter(function(p){ return p.id === seedId.toUpperCase(); });
      if(found.length > 0) return { pattern: found[0], reason: 'seeded' };
      log('w', 'Pattern '+seedId+' not found, falling back to random');
    }

    var candidates;
    if(mode === 'tag' && tagFilter){
      candidates = patterns.filter(function(p){ return p.category === tagFilter; });
      if(candidates.length === 0){
        log('w', 'No patterns for tag '+tagFilter+', using all');
        candidates = patterns;
      }
    } else {
      candidates = patterns;
    }

    var available = candidates.filter(function(p){
      return recentIds.indexOf(p.id) === -1;
    });
    if(available.length === 0){
      log('w', 'All patterns used recently, resetting avoid list');
      available = candidates;
    }

    var totalWeight = 0;
    available.forEach(function(p){ totalWeight += (p.weight || 1); });

    var maxAttempts = Math.min(available.length, 10);
    var recentTexts = [];
    for(var i=0; i<Math.min(recentIds.length, 5); i++){
      var rp = patterns.filter(function(p){ return p.id === recentIds[i]; })[0];
      if(rp) recentTexts.push(patternToText(rp));
    }

    for(var attempt=0; attempt < maxAttempts; attempt++){
      var r = Math.random() * totalWeight;
      var acc = 0;
      var pick = available[0];
      for(var j=0; j<available.length; j++){
        acc += (available[j].weight || 1);
        if(acc >= r){ pick = available[j]; break; }
      }

      var pickText = patternToText(pick);
      var maxSim = 0;
      for(var k=0; k<recentTexts.length; k++){
        var sim = jaccardSimilarity(pickText, recentTexts[k]);
        if(sim > maxSim) maxSim = sim;
      }

      // NG filter check
      var ngIssues = ngFilter(pick.slides);
      var hasError = ngIssues.some(function(i){ return i.severity === 'err'; });

      if((maxSim < diversityThreshold && !hasError) || attempt === maxAttempts - 1){
        return { pattern: pick, reason: mode, similarity: maxSim, attempts: attempt + 1, ngIssues: ngIssues };
      }
    }

    return { pattern: available[0], reason: 'fallback', similarity: 1, attempts: maxAttempts, ngIssues: [] };
  }

  // ── Hook swap: replace slide 1 with a random hook ──────────────
  function swapHook(slides){
    if(!hooksLibrary || !hooksLibrary.hooks || hooksLibrary.hooks.length === 0) return { slides: slides, hookId: null };
    var recentHooks = getHookHistory().slice(0, 10);
    var available = hooksLibrary.hooks.filter(function(h){ return recentHooks.indexOf(h.id) === -1; });
    if(available.length === 0) available = hooksLibrary.hooks;
    var pick = available[Math.floor(Math.random() * available.length)];
    var newSlides = slides.slice();
    newSlides[0] = pick.text;
    addToHookHistory(pick.id);
    return { slides: newSlides, hookId: pick.id, hookTone: pick.tone };
  }

  // ── Constants ──────────────────────────────────────────────────
  var W = 1080, H = 1920, SAFE = 120;
  var LAYOUTS = ["poster_dark", "caption_subtle", "caption_light"];
  var POSITIONS = [
    "top-left", "top-center", "top-right",
    "bottom-left", "bottom-center", "bottom-right"
  ];
  var CROPS = ["wide", "zoom-in", "left-focus", "right-focus"];
  var DEFAULT_BG_TYPES = ["desk","desk","hand","hand","proof","desk"];

  // ── Slide-specific layout rules ────────────────────────────────
  // Slide 1 (hook): poster_dark preferred, top position, large font
  // Slides 2-4: mix of layouts, varied positions
  // Slide 5: proof slide, caption_subtle or poster_dark
  // Slide 6 (CTA): poster_dark or caption_light, bottom-center, extra padding
  var SLIDE_LAYOUT_RULES = {
    0: { layouts: ["poster_dark","poster_dark","caption_subtle"], positions: ["top-center","top-left","top-right"] },
    1: { layouts: ["poster_dark","caption_subtle","caption_light"], positions: ["top-left","top-center","bottom-left","bottom-center"] },
    2: { layouts: ["caption_subtle","poster_dark","caption_light"], positions: ["bottom-left","bottom-center","top-left","top-center"] },
    3: { layouts: ["caption_subtle","poster_dark","caption_light"], positions: ["top-right","top-center","bottom-right","bottom-center"] },
    4: { layouts: ["poster_dark","caption_subtle"], positions: ["bottom-center","bottom-left","bottom-right"] },
    5: { layouts: ["poster_dark","caption_light"], positions: ["bottom-center","top-center"] }
  };

  // ── Utility ────────────────────────────────────────────────────
  function shuffle(arr){
    for(var i=arr.length-1;i>0;i--){
      var j=Math.floor(Math.random()*(i+1));
      var tmp=arr[i]; arr[i]=arr[j]; arr[j]=tmp;
    }
    return arr;
  }

  function pickRandom(arr){
    return arr[Math.floor(Math.random()*arr.length)];
  }

  // ── Slide-aware layout assignment ──────────────────────────────
  function assignLayouts(){
    var result = [];
    for(var i=0;i<6;i++){
      var rule = SLIDE_LAYOUT_RULES[i];
      result.push(pickRandom(rule.layouts));
    }
    // Ensure we have at least 2 different layouts
    var unique = {};
    result.forEach(function(l){ unique[l]=1; });
    if(Object.keys(unique).length < 2){
      // Force diversity: swap one middle slide
      var alt = LAYOUTS.filter(function(l){ return l !== result[2]; });
      result[2] = pickRandom(alt);
    }
    return result;
  }

  // ── Slide-aware position assignment ────────────────────────────
  function assignPositions(){
    var result = [];
    for(var i=0;i<6;i++){
      var rule = SLIDE_LAYOUT_RULES[i];
      result.push(pickRandom(rule.positions));
    }
    return result;
  }

  function assignCrops(){
    var pool=[];
    while(pool.length<6) pool=pool.concat(shuffle(CROPS.slice()));
    return pool.slice(0,6);
  }

  // ── Crop logic ─────────────────────────────────────────────────
  function getCropRegion(srcW, srcH, cropVariant){
    var targetRatio = W/H;
    var extractW, extractH, left, top;

    if(cropVariant==="zoom-in"){
      extractW=Math.round(srcW*0.65);
      extractH=Math.round(extractW/targetRatio);
      if(extractH>srcH*0.65){
        extractH=Math.round(srcH*0.65);
        extractW=Math.round(extractH*targetRatio);
      }
      left=Math.round((srcW-extractW)/2);
      top=Math.round((srcH-extractH)/2);
    } else if(cropVariant==="left-focus"){
      extractH=srcH;
      extractW=Math.round(extractH*targetRatio);
      if(extractW>srcW){ extractW=srcW; extractH=Math.round(srcW/targetRatio); }
      left=0;
      top=Math.round((srcH-extractH)/2);
    } else if(cropVariant==="right-focus"){
      extractH=srcH;
      extractW=Math.round(extractH*targetRatio);
      if(extractW>srcW){ extractW=srcW; extractH=Math.round(srcW/targetRatio); }
      left=Math.max(0,srcW-extractW);
      top=Math.round((srcH-extractH)/2);
    } else {
      var srcRatio=srcW/srcH;
      if(srcRatio>targetRatio){
        extractH=srcH;
        extractW=Math.round(srcH*targetRatio);
        left=Math.round((srcW-extractW)/2);
        top=0;
      } else {
        extractW=srcW;
        extractH=Math.round(srcW/targetRatio);
        left=0;
        top=Math.round((srcH-extractH)/2);
      }
    }

    extractW=Math.min(extractW,srcW-left);
    extractH=Math.min(extractH,srcH-top);
    return {left:left, top:top, width:extractW, height:extractH};
  }

  // ── Preload background images per type ─────────────────────────
  var bgImageSets = { desk: [], hand: [], proof: [] };
  var bgLoadStatus = { desk: false, hand: false, proof: false };
  var BG_COUNT = 6;

  function preloadBgType(type, callback){
    if(bgLoadStatus[type]){ callback(); return; }
    var loaded = 0;
    var imgs = [];
    var basePath = type === 'desk' ? 'bg/' : 'bg/'+type+'/';

    for(var i=0; i<BG_COUNT; i++){
      (function(idx){
        var img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = function(){
          imgs[idx] = img;
          loaded++;
          if(loaded===BG_COUNT){
            bgImageSets[type] = imgs;
            bgLoadStatus[type] = true;
            callback();
          }
        };
        img.onerror = function(){
          // Fallback to desk type if hand/proof not available
          if(type !== 'desk'){
            imgs[idx] = bgImageSets.desk[idx] || null;
          }
          loaded++;
          if(loaded===BG_COUNT){
            bgImageSets[type] = imgs;
            bgLoadStatus[type] = true;
            callback();
          }
        };
        img.src = basePath+(idx+1)+'.jpg';
      })(i);
    }
  }

  function preloadAllBgTypes(bgTypes, callback){
    var typesNeeded = {};
    bgTypes.forEach(function(t){ typesNeeded[t] = true; });
    // Always need desk as fallback
    typesNeeded.desk = true;
    var types = Object.keys(typesNeeded);
    var done = 0;

    function check(){
      done++;
      if(done === types.length) callback();
    }

    types.forEach(function(t){ preloadBgType(t, check); });
  }

  // ── Get background image for a slide ───────────────────────────
  function getBgImage(slideIndex, bgType){
    var imgs = bgImageSets[bgType];
    if(imgs && imgs[slideIndex]) return imgs[slideIndex];
    // Fallback: use desk type
    var deskImgs = bgImageSets.desk;
    if(deskImgs && deskImgs[slideIndex]) return deskImgs[slideIndex];
    return null;
  }

  // ── Canvas: draw text overlay (slide-aware sizing) ─────────────
  function drawTextOverlay(ctx, lines, layout, position, brand, slideIndex){
    var linesFiltered = lines.filter(function(l){ return l.length>0; });

    // Slide-specific font sizing
    var fontSize, maxLines;
    if(slideIndex === 0){
      // Hook: larger, bolder
      fontSize = lines.some(function(l){ return l.length>20; }) ? 72 : 88;
      maxLines = 2;
    } else if(slideIndex === 5){
      // CTA: slightly smaller for breathing room
      fontSize = lines.some(function(l){ return l.length>25; }) ? 60 : 68;
      maxLines = 2;
    } else {
      // Body slides
      fontSize = lines.some(function(l){ return l.length>25; }) ? 64 : 76;
      maxLines = 2;
    }

    // Truncate to maxLines
    if(linesFiltered.length > maxLines) linesFiltered = linesFiltered.slice(0, maxLines);

    var lineHeight = fontSize * 1.35;
    var textBlockH = linesFiltered.length * lineHeight;
    var boxPadH = slideIndex === 5 ? 56 : 44; // Extra padding for CTA
    var boxPadW = 56;
    var boxW = Math.min(W - SAFE*2, 880);
    var boxH = textBlockH + boxPadH*2;
    var boxR = 20;

    var boxX = (W - boxW) / 2;
    var boxY;
    if(position.indexOf("top")===0){
      boxY = SAFE + 40;
    } else {
      boxY = H - SAFE - boxH - 40;
    }
    if(position.indexOf("left")!==-1) boxX = SAFE;
    else if(position.indexOf("right")!==-1) boxX = W - boxW - SAFE;

    var textAlign = "center";
    var textX = boxX + boxW/2;
    if(position.indexOf("left")!==-1){ textAlign="left"; textX = boxX + boxPadW; }
    else if(position.indexOf("right")!==-1){ textAlign="right"; textX = boxX + boxW - boxPadW; }

    ctx.save();
    if(layout==="poster_dark"){
      ctx.fillStyle = "rgba(0,0,0,0.65)";
    } else if(layout==="caption_light"){
      ctx.fillStyle = "rgba(255,255,255,0.55)";
    } else {
      ctx.fillStyle = "rgba(255,255,255,0.18)";
    }
    roundRect(ctx, boxX, boxY, boxW, boxH, boxR);
    ctx.fill();
    ctx.restore();

    ctx.save();
    var fontWeight = slideIndex === 0 ? "800" : "800";
    ctx.font = fontWeight+" "+fontSize+"px 'Inter','Helvetica Neue',Arial,sans-serif";
    ctx.textAlign = textAlign;
    ctx.textBaseline = "alphabetic";

    if(layout==="caption_light"){
      ctx.fillStyle = "#111111";
    } else {
      ctx.fillStyle = "#ffffff";
    }

    if(layout==="caption_subtle"){
      ctx.shadowColor = "rgba(0,0,0,0.55)";
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 3;
      ctx.shadowBlur = 16;
    }

    var textY = boxY + boxPadH + fontSize;
    for(var i=0;i<linesFiltered.length;i++){
      ctx.fillText(linesFiltered[i], textX, textY + i*lineHeight);
    }
    ctx.restore();

    if(brand){
      ctx.save();
      ctx.font = "500 26px 'Inter','Helvetica Neue',Arial,sans-serif";
      ctx.textAlign = "end";
      ctx.fillStyle = "rgba(255,255,255,0.35)";
      ctx.shadowColor = "rgba(0,0,0,0.55)";
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 3;
      ctx.shadowBlur = 16;
      ctx.fillText("SimpleMemo (captio-style)", W - SAFE, H - 34);
      ctx.restore();
    }
  }

  function roundRect(ctx, x, y, w, h, r){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.lineTo(x+w-r, y);
    ctx.quadraticCurveTo(x+w, y, x+w, y+r);
    ctx.lineTo(x+w, y+h-r);
    ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
    ctx.lineTo(x+r, y+h);
    ctx.quadraticCurveTo(x, y+h, x, y+h-r);
    ctx.lineTo(x, y+r);
    ctx.quadraticCurveTo(x, y, x+r, y);
    ctx.closePath();
  }

  // ── Compose single slide on canvas ─────────────────────────────
  function composeSlide(bgImg, lines, layout, position, cropVariant, brand, slideIndex){
    var canvas = document.createElement('canvas');
    canvas.width = W;
    canvas.height = H;
    var ctx = canvas.getContext('2d');

    var crop = getCropRegion(bgImg.naturalWidth, bgImg.naturalHeight, cropVariant);
    ctx.drawImage(bgImg, crop.left, crop.top, crop.width, crop.height, 0, 0, W, H);

    drawTextOverlay(ctx, lines, layout, position, brand, slideIndex);

    return canvas;
  }

  // ── Canvas to Blob ─────────────────────────────────────────────
  function canvasToBlob(canvas){
    return new Promise(function(resolve){
      canvas.toBlob(function(blob){ resolve(blob); }, 'image/png');
    });
  }

  // ── Init 6 empty slots ─────────────────────────────────────────
  function initSlots(){
    gridEl.innerHTML = '';
    for(var i=0;i<6;i++){
      var s = document.createElement('div');
      s.className = 'slot'; s.id = 'slot-'+i;
      s.innerHTML = '<span class="slot-n">'+(i+1)+'</span>'
        +'<span class="slot-type" id="type-'+i+'"></span>'
        +'<div class="slot-img" id="img-'+i+'">—</div>'
        +'<div class="slot-meta"><span id="meta-'+i+'"></span><button class="btn-sm btn-outline" data-i="'+i+'" style="display:none">Regen</button></div>';
      gridEl.appendChild(s);
    }
    gridEl.querySelectorAll('[data-i]').forEach(function(btn){
      btn.addEventListener('click', function(){ regenSlide(parseInt(btn.dataset.i)); });
    });
  }
  initSlots();

  function showSlide(i, url, meta, bgType){
    var wrap = $('img-'+i);
    wrap.innerHTML = '<img src="'+url+'">';
    var metaEl = $('meta-'+i);
    metaEl.textContent = meta || '';
    var typeEl = $('type-'+i);
    if(bgType){
      typeEl.textContent = bgType;
      typeEl.className = 'slot-type t-'+bgType;
    }
    var btn = gridEl.querySelector('[data-i="'+i+'"]');
    if(btn) btn.style.display = '';
  }

  // ── UI: show/hide mode-specific controls ───────────────────────
  $('pattern-mode').addEventListener('change', function(){
    var mode = this.value;
    $('tag-select-wrap').style.display = mode === 'tag' ? '' : 'none';
    $('seed-wrap').style.display = mode === 'seeded' ? '' : 'none';
  });

  // ── Reload categories when variant changes ─────────────────────
  $('variant').addEventListener('change', function(){
    loadPatterns(this.value);
  });

  // ── Diversity threshold mapping ────────────────────────────────
  function getDiversityThreshold(){
    var val = $('diversity').value;
    if(val === 'low') return 0.2;
    if(val === 'high') return 0.6;
    return 0.4;
  }

  // ── Generate 6 slides ──────────────────────────────────────────
  $('gen-btn').addEventListener('click', async function(){
    var btn = $('gen-btn');
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner"></span>Generating...';
    $('status').textContent = '';
    $('dl-row').style.display = 'none';
    $('pattern-badge').innerHTML = '';
    initSlots();
    currentBlobs = [];
    currentPattern = null;
    currentTexts = null;

    var variant = $('variant').value;
    var brand = $('brand').checked;
    var hookSwap = $('hook-swap').checked;
    var mode = $('pattern-mode').value;
    var tagFilter = $('tag-select').value;
    var seedId = $('seed-input').value.trim();
    var avoidN = parseInt($('avoid-recent').value) || 20;
    var divThreshold = getDiversityThreshold();
    var t0 = Date.now();

    log('i', 'Generating variant='+variant+' mode='+mode+' hookSwap='+hookSwap+' diversity='+$('diversity').value+' avoidRecent='+avoidN);

    // Load pattern library & hooks
    var lib = await loadPatterns(variant);
    if(hookSwap) await loadHooks();

    var texts;
    var selectedPattern = null;
    var safetyResult = null;
    var similarity = 0;
    var ngIssues = [];
    var swappedHookId = null;
    var bgTypes = DEFAULT_BG_TYPES;

    if(lib){
      var selection = selectPattern(lib, mode, tagFilter, seedId, avoidN, divThreshold);
      selectedPattern = selection.pattern;
      similarity = selection.similarity || 0;
      ngIssues = selection.ngIssues || [];
      currentPattern = selectedPattern;

      // Safety check
      safetyResult = checkSafety(selectedPattern, lib);
      if(!safetyResult.passed){
        log('w', 'Safety filter triggered for '+selectedPattern.id+': '+safetyResult.bannedHits.join(', '));
        for(var retry=0; retry<5; retry++){
          selection = selectPattern(lib, 'random', '', '', avoidN, divThreshold);
          selectedPattern = selection.pattern;
          similarity = selection.similarity || 0;
          ngIssues = selection.ngIssues || [];
          currentPattern = selectedPattern;
          safetyResult = checkSafety(selectedPattern, lib);
          if(safetyResult.passed) break;
        }
      }

      texts = selectedPattern.slides.map(function(s){ return s.slice(); }); // deep copy
      bgTypes = selectedPattern.bgTypes || lib.defaultBgTypes || DEFAULT_BG_TYPES;

      // Hook swap
      if(hookSwap && hooksLibrary){
        var result = swapHook(texts);
        texts = result.slides;
        swappedHookId = result.hookId;
        if(swappedHookId){
          log('i', 'Hook swapped → '+swappedHookId+' ('+result.hookTone+')');
        }
      }

      addToHistory(selectedPattern.id);

      log('i', 'Pattern: '+selectedPattern.id+' ['+selectedPattern.category+'] sim='+similarity.toFixed(3)+' attempts='+selection.attempts);
      log('i', 'BgTypes: '+bgTypes.join(' → '));

      // Log NG issues
      if(ngIssues.length > 0){
        ngIssues.forEach(function(issue){
          if(issue.type === 'word_repeat'){
            log('w', 'NG: "'+issue.word+'" repeated in '+issue.count+' slides');
          } else if(issue.type === 'abstract_only'){
            log('w', 'NG: Slide '+issue.slide+' is abstract-only');
          } else if(issue.type === 'long_hook'){
            log('err', 'NG: Hook has '+issue.words+' words (max 12)');
          }
        });
      }

      if(safetyResult && safetyResult.cautionHits.length > 0){
        log('w', 'Caution words: '+safetyResult.cautionHits.join(', '));
      }

      // Show pattern badge
      var badgeCls = safetyResult && safetyResult.passed ? 'badge-ok' : 'badge-err';
      var badgeHtml = '<span class="badge '+badgeCls+'">'+selectedPattern.id+'</span>'
        + '<span class="badge badge-ok">'+selectedPattern.category+'</span>'
        + '<span class="badge badge-blue">sim: '+similarity.toFixed(2)+'</span>';
      if(swappedHookId){
        badgeHtml += '<span class="badge badge-warn">hook: '+swappedHookId+'</span>';
      }
      if(ngIssues.length > 0){
        var ngCount = ngIssues.length;
        badgeHtml += '<span class="badge badge-warn">NG: '+ngCount+'</span>';
      }
      $('pattern-badge').innerHTML = badgeHtml;
    } else {
      log('w', 'No pattern library loaded, cannot generate');
      btn.disabled = false;
      btn.textContent = 'Generate 6 Slides';
      return;
    }

    currentTexts = texts;

    log('i', 'Loading backgrounds ('+bgTypes.filter(function(t,i,a){return a.indexOf(t)===i;}).join(', ')+')...');

    preloadAllBgTypes(bgTypes, function(){
      log('ok', 'Backgrounds loaded');

      var layouts = assignLayouts();
      var positions = assignPositions();
      var crops = assignCrops();

      var textLengths = texts.map(function(s){
        return s.filter(function(l){return l;}).join(' ').length;
      });

      var plan = {
        generated_at: new Date().toISOString(),
        variant: variant,
        brand: brand,
        hook_swap: hookSwap,
        swapped_hook_id: swappedHookId,
        output_size: W+'x'+H,
        pattern_id: selectedPattern ? selectedPattern.id : 'fallback',
        pattern_category: selectedPattern ? selectedPattern.category : null,
        pattern_tags: selectedPattern ? selectedPattern.tags : [],
        pattern_structure: selectedPattern ? selectedPattern.structure : null,
        bg_types: bgTypes,
        similarity_score: similarity,
        ng_issues: ngIssues,
        safety_filter_result: safetyResult ? {
          passed: safetyResult.passed,
          banned_hits: safetyResult.bannedHits,
          caution_hits: safetyResult.cautionHits,
          app_name_count: safetyResult.appNameCount
        } : null,
        text_length_per_slide: textLengths,
        diversity_setting: $('diversity').value,
        avoid_recent_n: avoidN,
        pattern_mode: mode,
        slides: []
      };

      var generated = 0;

      function processSlide(i){
        var bgType = bgTypes[i] || 'desk';
        var bgImg = getBgImage(i, bgType);
        if(!bgImg){
          log('err', 'No background for slide '+(i+1)+' ('+bgType+'), using desk fallback');
          bgImg = getBgImage(i, 'desk');
        }
        if(!bgImg){
          log('err', 'No background available for slide '+(i+1));
          generated++;
          return;
        }

        var canvas = composeSlide(bgImg, texts[i], layouts[i], positions[i], crops[i], brand, i);

        plan.slides.push({
          slide_index: i,
          background: (i+1)+'.jpg',
          bg_type: bgType,
          text: texts[i],
          text_length: textLengths[i],
          layout_variant: layouts[i],
          text_position: positions[i],
          crop_variant: crops[i],
          brand: brand
        });

        canvasToBlob(canvas).then(function(blob){
          currentBlobs[i] = blob;
          var sizeKB = Math.round(blob.size/1024);
          var url = URL.createObjectURL(blob);
          var meta = layouts[i]+' \u00b7 '+crops[i]+' \u00b7 '+sizeKB+'KB';
          showSlide(i, url, meta, bgType);
          log('ok', 'Slide '+(i+1)+': '+bgType+' / '+layouts[i]+' / '+positions[i]+' / '+crops[i]);

          generated++;
          if(generated===6){
            currentPlan = plan;
            var sec = ((Date.now()-t0)/1000).toFixed(1);
            $('status').textContent = '6枚生成完了 ('+sec+'s)' + (selectedPattern ? ' — Pattern '+selectedPattern.id : '');
            $('timer').textContent = sec+'s';
            $('dl-row').style.display = 'flex';
            log('ok', 'Done in '+sec+'s — Pattern: '+(selectedPattern ? selectedPattern.id+' ['+selectedPattern.category+']' : 'fallback'));
            btn.disabled = false;
            btn.textContent = 'Generate 6 Slides';
          }
        });
      }

      for(var i=0;i<6;i++){
        processSlide(i);
      }
    });
  });

  // ── Regenerate single slide ────────────────────────────────────
  function regenSlide(index){
    if(!currentPlan || !currentTexts) return;
    var btn = gridEl.querySelector('[data-i="'+index+'"]');
    btn.textContent = '...';

    var brand = $('brand').checked;
    var texts = currentTexts;
    var bgType = (currentPlan.bg_types && currentPlan.bg_types[index]) || 'desk';
    var bgImg = getBgImage(index, bgType);
    if(!bgImg) bgImg = getBgImage(index, 'desk');
    if(!bgImg){ log('err', 'No background for regen'); return; }

    log('i', 'Regenerating slide '+(index+1)+'...');

    var rule = SLIDE_LAYOUT_RULES[index];
    var layout = pickRandom(rule.layouts);
    var position = pickRandom(rule.positions);
    var crop = CROPS[Math.floor(Math.random()*CROPS.length)];

    var canvas = composeSlide(bgImg, texts[index], layout, position, crop, brand, index);

    canvasToBlob(canvas).then(function(blob){
      currentBlobs[index] = blob;

      currentPlan.slides[index] = {
        slide_index: index,
        background: (index+1)+'.jpg',
        bg_type: bgType,
        text: texts[index],
        text_length: texts[index].filter(function(l){return l;}).join(' ').length,
        layout_variant: layout,
        text_position: position,
        crop_variant: crop,
        brand: brand
      };

      var sizeKB = Math.round(blob.size/1024);
      var url = URL.createObjectURL(blob);
      showSlide(index, url, layout+' \u00b7 '+crop+' \u00b7 '+sizeKB+'KB', bgType);
      btn.textContent = 'Regen';
      log('ok', 'Slide '+(index+1)+' regenerated: '+bgType+' / '+layout+' / '+position+' / '+crop);
    });
  }

  // ── ZIP download ───────────────────────────────────────────────
  $('zip-btn').addEventListener('click', function(){
    if(!currentPlan || currentBlobs.length<6) return;
    var zipBtn = $('zip-btn');
    zipBtn.textContent = 'Packing...';
    zipBtn.disabled = true;
    log('i', 'Creating ZIP...');

    var zip = new JSZip();

    for(var i=0;i<6;i++){
      (function(idx){
        var blob = currentBlobs[idx];
        if(blob){
          zip.file('slide_'+(idx+1)+'.png', blob);
        }
      })(i);
    }

    zip.file('slide_plan.json', JSON.stringify(currentPlan, null, 2));

    zip.generateAsync({type:'blob'}).then(function(content){
      var a = document.createElement('a');
      a.href = URL.createObjectURL(content);
      var ts = new Date().toISOString().replace(/[:.]/g,'-').slice(0,19);
      a.download = 'slides_'+currentPlan.variant+'_'+(currentPlan.pattern_id||'fb')+'_'+ts+'.zip';
      a.click();
      zipBtn.textContent = 'ZIP Download';
      zipBtn.disabled = false;
      log('ok', 'ZIP downloaded: '+a.download);
    });
  });

  // ── Post to TikTok via Postiz ──────────────────────────────────
  $('tiktok-btn').addEventListener('click', async function(){
    if(!currentPlan || currentBlobs.length<6){
      log('err', 'スライドを先に生成してください'); return;
    }
    var btn = $('tiktok-btn');
    btn.disabled = true;
    btn.textContent = '送信中...';
    log('i', 'TikTok投稿を開始…');

    try {
      var uploaded = [];
      for(var i=0;i<6;i++){
        var blob = currentBlobs[i];
        var form = new FormData();
        form.append('file', blob, 'slide_'+(i+1)+'.png');

        log('i', 'slide_'+(i+1)+'.png アップロード中…');
        var res = await fetch('/admin/api/upload', { method: 'POST', body: form });
        var data = await res.json();
        if(!res.ok) throw new Error('Upload failed: slide_'+(i+1)+' ('+res.status+') '+(data.error||JSON.stringify(data)));
        uploaded.push({ id: data.id, path: data.path });
        log('ok', 'slide_'+(i+1)+'.png → '+data.path);
      }

      var hook = currentPlan.slides[0].text.filter(function(t){return t;}).join(' ');
      var caption = hook + '\n\nSimple Memo - one tap, straight to your inbox.\n\n#simplememo #productivity #notetaking #lifehack #iphone';

      log('i', '投稿作成中（1分後に予約）…');
      var postRes = await fetch('/admin/api/post-tiktok', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ images: uploaded, caption: caption })
      });
      var postData = await postRes.json();
      if(!postRes.ok) throw new Error('Post failed: '+JSON.stringify(postData));

      log('ok', 'TikTok投稿を予約しました！ ('+postData.scheduleDate+')');
      log('ok', '約1分後にTikTokへ送信 → システム通知が届きます');
      btn.textContent = '送信完了!';
      setTimeout(function(){ btn.textContent = 'TikTokへ送る'; btn.disabled = false; }, 3000);
    } catch(e) {
      log('err', 'エラー: '+e.message);
      btn.textContent = 'TikTokへ送る';
      btn.disabled = false;
    }
  });

  // ── Export log (enhanced) ──────────────────────────────────────
  $('log-btn').addEventListener('click', function(){
    if(!currentPlan) return;
    var json = JSON.stringify(currentPlan, null, 2);
    var blob = new Blob([json], {type:'application/json'});
    var a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'slide_plan_'+(currentPlan.pattern_id||'fb')+'_'+new Date().toISOString().replace(/[:.]/g,'-').slice(0,19)+'.json';
    a.click();
    log('i', 'Exported '+a.download);
  });

  // ── Init ───────────────────────────────────────────────────────
  log('i', 'Ready. Select variant and click Generate.');
  log('i', 'Loading pattern libraries...');
  loadPatterns('A');
  loadHooks();
})();
</script>

</body>
</html>
